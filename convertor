package complexesqloJava;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class EsqlToJavaConverter {

    private static final String OUTPUT_DIR = "generated/";
    private static final String MODEL_PACKAGE = "com.example.model";
    private static final String MAPPER_PACKAGE = "com.example.mapper";

    private static final Map<String, String> TYPE_MAPPING = new HashMap<>();
    static {
        TYPE_MAPPING.put("INTEGER", "Integer");
        TYPE_MAPPING.put("FLOAT", "Float");
        TYPE_MAPPING.put("DECIMAL", "Double");
        TYPE_MAPPING.put("CHARACTER", "String");
        TYPE_MAPPING.put("BOOLEAN", "Boolean");
    }

    private static final Pattern PROCEDURE_PATTERN = Pattern.compile("CREATE\\s+PROCEDURE\\s+(\\w+)\\s*\\(\\s*\\)\\s*BEGIN\\s+(.+?)\\s+END\\s*;", Pattern.DOTALL);
    private static final Pattern ASSIGNMENT_PATTERN = Pattern.compile("SET\\s+([^=]+)\\s*=\\s*([^;]+);", Pattern.DOTALL);
    private static final Pattern INPUT_PATTERN = Pattern.compile("(InputRoot\\.(?:JSON\\.Data|XML|XMLNSC|MRM|DFDL|MQRFH2)(?:\\.\\*:?\\w+)*(?:\\.Item\\[.*?\\])?)\\.([\\w*:]+)", Pattern.DOTALL);
    private static final Pattern HEADER_PATTERN = Pattern.compile("([^\\.]+)\\.\"([^\"]+)\"", Pattern.DOTALL);
    private static final Pattern CAST_PATTERN = Pattern.compile("CAST\\(([^)]+)\\s+AS\\s+(\\w+)\\)", Pattern.DOTALL);
    private static final Pattern COALESCE_PATTERN = Pattern.compile("COALESCE\\(([^,]+(?:,[^,]+)*)\\)", Pattern.DOTALL);
    private static final Pattern FOR_PATTERN = Pattern.compile("FOR\\s+(\\w+)\\s+AS\\s+([^)]+)\\s+DO\\s+(.+?)\\s+END FOR", Pattern.DOTALL);
    private static final Pattern WHILE_PATTERN = Pattern.compile("WHILE\\s+LASTMOVE\\s*\\((\\w+)\\)\\s+DO\\s+(.+?)\\s+END WHILE", Pattern.DOTALL);
    private static final Pattern REFERENCE_PATTERN = Pattern.compile("DECLARE\\s+(\\w+)\\s+REFERENCE\\s+TO\\s+([^;]+);", Pattern.DOTALL);
    private static final Pattern DECLARE_PATTERN = Pattern.compile("DECLARE\\s+(\\w+)\\s+(INTEGER|FLOAT|DECIMAL|CHARACTER|BOOLEAN)(?:\\s+(\\d+|'.*?'))?;", Pattern.DOTALL);
    private static final Pattern SUBSTRING_PATTERN = Pattern.compile("SUBSTRING\\(([^)]+)\\s+(AFTER|BEFORE)\\s*'([^']*)'\\)", Pattern.DOTALL);
    private static final Pattern MOVE_PATTERN = Pattern.compile("MOVE\\s+(\\w+)\\s+FIRSTCHILD\\s*;", Pattern.DOTALL);
    private static final Pattern DATE_PATTERN = Pattern.compile("DATE_FORMAT\\(([^,]+),\\s*'([^']+)'\\)", Pattern.DOTALL);
    private static final Pattern CREATE_LASTCHILD_PATTERN = Pattern.compile("CREATE\\s+LASTCHILD\\s+OF\\s+([^\\s]+)\\s+DOMAIN\\s*\\('[^']+'\\)\\s*;", Pattern.DOTALL);
    private static final Pattern CREATE_FIELD_PATTERN = Pattern.compile("CREATE\\s+FIELD\\s+([^\\s]+)\\.(\\w+)\\s*(?:TYPE\\s+NAME\\s+(\\w+))?;", Pattern.DOTALL);
    private static final Pattern LOOP_INDEX_PATTERN = Pattern.compile("SET\\s+([^=]+)\\.Item\\[(\\w+)\\]\\.(\\w+)\\s*=\\s*([^;]+);", Pattern.DOTALL);
    private static final Pattern ARRAY_INDEX_PATTERN = Pattern.compile("SET\\s+([^=]+)\\.(\\w+)\\[(\\d+)\\]\\.(\\w+)\\s*=\\s*([^;]+);", Pattern.DOTALL);
    private static final Pattern IF_PATTERN = Pattern.compile("IF\\s+(.+?)\\s+THEN\\s+(.+?)\\s+(?:ELSE\\s+(.+?)\\s+)?END\\s+IF", Pattern.DOTALL);

    public static void main(String[] args) {
        String esqlFilePath = args.length > 0 ? args[0] : "input.esql";
        try {
            String esqlScript = readEsqlFromFile(esqlFilePath);
            new File(OUTPUT_DIR).mkdirs();
            Map<String, Object> parseResult = parseEsqlScript(esqlScript);
            generateModelClasses(parseResult);
            generateMapperClass(parseResult);
            System.out.println("Conversion completed successfully. Files generated in " + OUTPUT_DIR);
        } catch (Exception e) {
            System.err.println("Error during conversion: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static String readEsqlFromFile(String filePath) throws IOException {
        StringBuilder content = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
        }
        return content.toString();
    }

    private static Map<String, Object> parseEsqlScript(String esqlScript) {
        Map<String, Object> result = new HashMap<>();
        Map<String, ClassStructure> classes = new HashMap<>();
        List<String> logicBlocks = new ArrayList<>();
        Map<String, List<String>> procedureBlocks = new HashMap<>();
        Map<String, String> references = new HashMap<>();
        Map<String, String> variables = new HashMap<>();
        Set<String> headerKeys = new HashSet<>();

        ClassStructure inputClass = classes.computeIfAbsent("Input", ClassStructure::new);
        ClassStructure outputClass = classes.computeIfAbsent("Output", ClassStructure::new);
        ClassStructure envClass = classes.computeIfAbsent("Environment", ClassStructure::new);

        Matcher declareMatcher = DECLARE_PATTERN.matcher(esqlScript);
        while (declareMatcher.find()) {
            String varName = declareMatcher.group(1);
            String varType = TYPE_MAPPING.getOrDefault(declareMatcher.group(2).toUpperCase(), "String");
            String varValue = declareMatcher.group(3) != null ? declareMatcher.group(3).replaceAll("'", "\"") : "null";
            variables.put(varName, varType + ":" + varValue);
        }

        Matcher referenceMatcher = REFERENCE_PATTERN.matcher(esqlScript);
        while (referenceMatcher.find()) {
            references.put(referenceMatcher.group(1).trim(), referenceMatcher.group(2).trim());
        }

        Matcher procedureMatcher = PROCEDURE_PATTERN.matcher(esqlScript);
        while (procedureMatcher.find()) {
            String procedureName = procedureMatcher.group(1);
            String body = procedureMatcher.group(2);
            List<String> procLogic = new ArrayList<>();
            parseProcedureBody(body, procLogic, classes, inputClass, outputClass, envClass, references, headerKeys, variables);
            procedureBlocks.put(procedureName, procLogic);
        }

        Matcher assignmentMatcher = ASSIGNMENT_PATTERN.matcher(esqlScript);
        while (assignmentMatcher.find()) {
            if (!isWithinProcedure(assignmentMatcher.start(), procedureMatcher)) {
                processAssignment(assignmentMatcher.group(1).trim(), assignmentMatcher.group(2).trim(), logicBlocks,
                        classes, inputClass, outputClass, envClass, references, headerKeys, variables, null);
            }
        }

        Matcher arrayIndexMatcher = ARRAY_INDEX_PATTERN.matcher(esqlScript);
        while (arrayIndexMatcher.find()) {
            if (!isWithinProcedure(arrayIndexMatcher.start(), procedureMatcher)) {
                processArrayAssignment(arrayIndexMatcher.group(1).trim(), arrayIndexMatcher.group(2).trim(),
                        arrayIndexMatcher.group(3).trim(), arrayIndexMatcher.group(4).trim(),
                        arrayIndexMatcher.group(5).trim(), logicBlocks, classes, inputClass, outputClass,
                        envClass, references, headerKeys, variables);
            }
        }

        Matcher forMatcher = FOR_PATTERN.matcher(esqlScript);
        while (forMatcher.find()) {
            if (!isWithinProcedure(forMatcher.start(), procedureMatcher)) {
                processForLoop(forMatcher.group(1), forMatcher.group(2), forMatcher.group(3), logicBlocks, classes,
                        inputClass, outputClass, envClass, references, variables, 0);
            }
        }

        Matcher whileMatcher = WHILE_PATTERN.matcher(esqlScript);
        while (whileMatcher.find()) {
            if (!isWithinProcedure(whileMatcher.start(), procedureMatcher)) {
                processWhileLoop(whileMatcher.group(1), whileMatcher.group(2), esqlScript.substring(0, whileMatcher.start()),
                        logicBlocks, classes, inputClass, outputClass, envClass, references, variables);
            }
        }

        Matcher createLastChildMatcher = CREATE_LASTCHILD_PATTERN.matcher(esqlScript);
        while (createLastChildMatcher.find()) {
            processCreateLastChild(createLastChildMatcher.group(1), logicBlocks, classes, outputClass, envClass, references);
        }

        Matcher createFieldMatcher = CREATE_FIELD_PATTERN.matcher(esqlScript);
        while (createFieldMatcher.find()) {
            processCreateField(createFieldMatcher.group(1), createFieldMatcher.group(2), createFieldMatcher.group(3), logicBlocks, classes, outputClass, envClass, references);
        }

        result.put("classes", classes);
        result.put("logicBlocks", logicBlocks);
        result.put("procedureBlocks", procedureBlocks);
        result.put("headerKeys", headerKeys);
        return result;
    }

    private static void parseProcedureBody(String body, List<String> procLogic, Map<String, ClassStructure> classes,
            ClassStructure inputClass, ClassStructure outputClass, ClassStructure envClass, Map<String, String> references,
            Set<String> headerKeys, Map<String, String> variables) {
        Matcher assignmentMatcher = ASSIGNMENT_PATTERN.matcher(body);
        while (assignmentMatcher.find()) {
            processAssignment(assignmentMatcher.group(1).trim(), assignmentMatcher.group(2).trim(), procLogic, classes,
                    inputClass, outputClass, envClass, references, headerKeys, variables, null);
        }

        Matcher arrayIndexMatcher = ARRAY_INDEX_PATTERN.matcher(body);
        while (arrayIndexMatcher.find()) {
            processArrayAssignment(arrayIndexMatcher.group(1).trim(), arrayIndexMatcher.group(2).trim(),
                    arrayIndexMatcher.group(3).trim(), arrayIndexMatcher.group(4).trim(),
                    arrayIndexMatcher.group(5).trim(), procLogic, classes, inputClass, outputClass,
                    envClass, references, headerKeys, variables);
        }

        Matcher forMatcher = FOR_PATTERN.matcher(body);
        while (forMatcher.find()) {
            processForLoop(forMatcher.group(1), forMatcher.group(2), forMatcher.group(3), procLogic, classes,
                    inputClass, outputClass, envClass, references, variables, 0);
        }

        Matcher whileMatcher = WHILE_PATTERN.matcher(body);
        while (whileMatcher.find()) {
            processWhileLoop(whileMatcher.group(1), whileMatcher.group(2), body.substring(0, whileMatcher.start()),
                    procLogic, classes, inputClass, outputClass, envClass, references, variables);
        }

        Matcher createLastChildMatcher = CREATE_LASTCHILD_PATTERN.matcher(body);
        while (createLastChildMatcher.find()) {
            processCreateLastChild(createLastChildMatcher.group(1), procLogic, classes, outputClass, envClass, references);
        }

        Matcher createFieldMatcher = CREATE_FIELD_PATTERN.matcher(body);
        while (createFieldMatcher.find()) {
            processCreateField(createFieldMatcher.group(1), createFieldMatcher.group(2), createFieldMatcher.group(3), procLogic, classes, outputClass, envClass, references);
        }
    }

    private static void processAssignment(String outputPath, String value, List<String> logicBlocks,
            Map<String, ClassStructure> classes, ClassStructure inputClass, ClassStructure outputClass,
            ClassStructure envClass, Map<String, String> references, Set<String> headerKeys, Map<String, String> variables, String iterator) {
        String resolvedOutputPath = resolveReference(outputPath, references);
        String resolvedValue = resolveReference(value, references);

        if (!resolvedOutputPath.matches("(OutputRoot\\.(JSON\\.Data|MRM|DFDL)|Environment).*") || resolvedOutputPath.contains("httpCode")
                || resolvedOutputPath.contains("httpMessage") || resolvedOutputPath.contains("moreInformation")
                || resolvedValue.contains("httpCode") || resolvedValue.contains("httpMessage")
                || resolvedValue.contains("moreInformation")) {
            return;
        }

        String fullOutputPath = resolvedOutputPath;
        String castType = null;
        String coalesceValue = null;
        String defaultValue = null;

        Matcher castMatcher = CAST_PATTERN.matcher(value);
        if (castMatcher.find()) {
            value = castMatcher.group(1).trim();
            castType = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
        }

        Matcher coalesceMatcher = COALESCE_PATTERN.matcher(value);
        if (coalesceMatcher.find()) {
            String[] args = coalesceMatcher.group(1).split(",");
            coalesceValue = args[0].trim();
            defaultValue = args.length > 1 ? args[1].trim().replaceAll("'", "\"") : "\"\"";
            value = coalesceValue;
        }

        ClassStructure targetClass = resolvedOutputPath.startsWith("Environment") ? envClass : outputClass;
        processPath(fullOutputPath, classes, targetClass, true, castType != null ? castType : value);

        Matcher inputMatcher = INPUT_PATTERN.matcher(value);
        while (inputMatcher.find()) {
            String inputPath = inputMatcher.group(1);
            String fieldName = inputMatcher.group(2).replace("*:", "");
            processPath(inputPath, classes, inputClass, false, null);
        }

        Matcher headerMatcher = HEADER_PATTERN.matcher(value);
        if (headerMatcher.find() && references.containsKey(headerMatcher.group(1))) {
            String refPath = references.get(headerMatcher.group(1));
            if (refPath.contains("HTTPRequestHeader")) {
                String headerKey = headerMatcher.group(2).toLowerCase();
                headerKeys.add(headerKey);
            }
        }

        String[] outputParts = resolvedOutputPath.split("\\.");
        String outputField = outputParts[outputParts.length - 1].toLowerCase();
        String setter = generateSetter(resolvedOutputPath, outputField, value, references, castType, coalesceValue, defaultValue, headerMatcher, iterator);
        logicBlocks.add(setter);
    }

    private static void processArrayAssignment(String outputPath, String arrayField, String index, String fieldName, String value,
            List<String> logicBlocks, Map<String, ClassStructure> classes, ClassStructure inputClass, ClassStructure outputClass,
            ClassStructure envClass, Map<String, String> references, Set<String> headerKeys, Map<String, String> variables) {
        String resolvedOutputPath = resolveReference(outputPath, references);
        String resolvedValue = resolveReference(value, references);

        if (!resolvedOutputPath.matches("(OutputRoot\\.(JSON\\.Data|MRM|DFDL)|Environment).*") || resolvedOutputPath.contains("httpCode")
                || resolvedOutputPath.contains("httpMessage") || resolvedOutputPath.contains("moreInformation")
                || resolvedValue.contains("httpCode") || resolvedValue.contains("httpMessage")
                || resolvedValue.contains("moreInformation")) {
            return;
        }

        ClassStructure targetClass = resolvedOutputPath.startsWith("Environment") ? envClass : outputClass;
        String arrayPath = resolvedOutputPath + "." + arrayField;
        processArrayPath(arrayPath, fieldName, classes, targetClass, true, value);

        Matcher inputMatcher = INPUT_PATTERN.matcher(value);
        while (inputMatcher.find()) {
            String inputPath = inputMatcher.group(1);
            String inputFieldName = inputMatcher.group(2).replace("*:", "");
            processPath(inputPath, classes, inputClass, false, null);
        }

        int javaIndex = Integer.parseInt(index) - 1; // ESQL uses 1-based indexing, Java uses 0-based
        StringBuilder setter = new StringBuilder();
        String root = resolvedOutputPath.startsWith("Environment") ? "environment" : "output";
        String[] parts = resolvedOutputPath.split("\\.");
        StringBuilder pathBuilder = new StringBuilder(root);

        for (int i = 1; i < parts.length; i++) {
            if (!parts[i].equals("MRM") && !parts[i].equals("DFDL")) {
                pathBuilder.append(".get").append(capitalize(parts[i].replace("*:", ""))).append("()");
            }
        }
        pathBuilder.append(".set").append(capitalize(arrayField)).append("(new ArrayList<>())");
        setter.append("if (").append(pathBuilder).append(" == null) ").append(pathBuilder).append(";\n");

        pathBuilder = new StringBuilder(root);
        for (int i = 1; i < parts.length; i++) {
            if (!parts[i].equals("MRM") && !parts[i].equals("DFDL")) {
                pathBuilder.append(".get").append(capitalize(parts[i].replace("*:", ""))).append("()");
            }
        }
        setter.append("while (").append(pathBuilder).append(".get").append(capitalize(arrayField)).append("().size() <= ").append(javaIndex).append(") {\n");
        setter.append("    ").append(pathBuilder).append(".get").append(capitalize(arrayField)).append("().add(new ").append(capitalize(arrayField)).append("());\n");
        setter.append("}\n");

        pathBuilder.append(".get").append(capitalize(arrayField)).append("().get(").append(javaIndex).append(")");
        String fieldSetter = pathBuilder + ".set" + capitalize(fieldName) + "(" + convertValue(resolvedValue, references, null) + ");";
        setter.append(fieldSetter);

        logicBlocks.add(setter.toString());
    }

    private static void processForLoop(String iterator, String collectionPath, String body, List<String> logicBlocks,
            Map<String, ClassStructure> classes, ClassStructure inputClass, ClassStructure outputClass,
            ClassStructure envClass, Map<String, String> references, Map<String, String> variables, int nestingLevel) {
        if (body.contains("httpCode") || body.contains("httpMessage") || body.contains("moreInformation")) {
            return;
        }

        String resolvedCollectionPath = resolveReference(collectionPath, references);
        String fullCollectionPath = resolvedCollectionPath.startsWith("InputRoot") ? resolvedCollectionPath
                : "InputRoot.JSON.Data." + resolvedCollectionPath;
        String collectionName = extractCollectionName(fullCollectionPath, true);
        String itemClassName = capitalize(collectionName.replaceAll("s$", ""));
        ClassStructure itemClass = classes.computeIfAbsent(itemClassName, ClassStructure::new);

        ClassStructure parentClass = nestingLevel == 0 ? inputClass : classes.get(capitalize(extractCollectionName(resolveReference(collectionPath.split("\\.")[0], references), true).replaceAll("s$", "")));
        parentClass.addField(collectionName, "List<" + itemClassName + ">");

        String outputCollectionPath = extractOutputCollection(body, references, collectionName);
        String[] outputParts = outputCollectionPath.split("\\.");
        String collectionField = outputParts[outputParts.length - 1].toLowerCase();

        Matcher bodyMatcher = LOOP_INDEX_PATTERN.matcher(body);
        while (bodyMatcher.find()) {
            String fieldName = bodyMatcher.group(3).toLowerCase();
            String value = bodyMatcher.group(4).trim();
            String type = determineFieldType(fieldName, outputCollectionPath, value);
            if (!fieldName.equals("httpcode") && !fieldName.equals("httpmessage") && !fieldName.equals("moreinformation")) {
                Matcher castMatcher = CAST_PATTERN.matcher(value);
                if (castMatcher.find()) {
                    type = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
                }
                itemClass.addField(fieldName, type);
            }
        }

        if (nestingLevel == 0) {
            outputClass.addField(collectionField, "List<" + itemClassName + ">");
        }

        StringBuilder loop = new StringBuilder();
        String indent = "    ".repeat(nestingLevel + 1);
        String counterVar = detectCounterVariable(body, variables);
        String counterStart = counterVar != null && variables.containsKey(counterVar) ? variables.get(counterVar).split(":")[1] : "0";

        loop.append(indent).append("List<").append(itemClassName).append("> ").append(collectionField).append(" = new ArrayList<>();\n")
            .append(indent).append("if (").append(nestingLevel == 0 ? "input" : iterator).append(".get").append(capitalize(collectionName)).append("() != null) {\n")
            .append(indent).append("    int ").append(counterVar != null ? counterVar.toLowerCase() : "counter").append(" = ").append(counterStart).append(";\n")
            .append(indent).append("    for (").append(itemClassName).append(" ").append(iterator).append(" : ").append(nestingLevel == 0 ? "input" : iterator).append(".get").append(capitalize(collectionName)).append("()) {\n")
            .append(indent).append("        ").append(itemClassName).append(" outputItem = new ").append(itemClassName).append("();\n")
            .append(convertLoopBodyWithCounter(body, iterator, "outputItem", counterVar, references, variables))
            .append(indent).append("        ").append(collectionField).append(".add(outputItem);\n")
            .append(indent).append("        ").append(counterVar != null ? counterVar.toLowerCase() : "counter").append("++;\n")
            .append(indent).append("    }\n")
            .append(indent).append("}\n");

        if (nestingLevel == 0) {
            loop.append(indent).append("output.set").append(capitalize(collectionField)).append("(").append(collectionField).append(");");
        }

        logicBlocks.add(loop.toString());
    }

    private static void processWhileLoop(String refName, String body, String priorContent, List<String> logicBlocks,
            Map<String, ClassStructure> classes, ClassStructure inputClass, ClassStructure outputClass,
            ClassStructure envClass, Map<String, String> references, Map<String, String> variables) {
        if (body.contains("httpCode") || body.contains("httpMessage") || body.contains("moreInformation")) {
            return;
        }

        String refPath = references.getOrDefault(refName, "");
        if (!refPath.matches("InputRoot\\.(XML|XMLNSC|MRM|DFDL|JSON\\.Data)(?:\\.\\*:?\\w+)*")) return;

        String collectionName = extractCollectionName(refPath, false);
        String itemClassName = capitalize(collectionName.replaceAll("s$", ""));
        ClassStructure itemClass = classes.computeIfAbsent(itemClassName, ClassStructure::new);

        inputClass.addField(collectionName, "List<" + itemClassName + ">");

        String outputCollectionPath = extractOutputCollection(body, references, collectionName);
        String[] outputParts = outputCollectionPath.split("\\.");
        String collectionField = outputParts[outputParts.length - 1].toLowerCase();

        Matcher bodyMatcher = LOOP_INDEX_PATTERN.matcher(body);
        while (bodyMatcher.find()) {
            String fieldName = bodyMatcher.group(3).toLowerCase();
            String value = bodyMatcher.group(4).trim();
            String type = determineFieldType(fieldName, outputCollectionPath, value);
            if (!fieldName.equals("httpcode") && !fieldName.equals("httpmessage") && !fieldName.equals("moreinformation")) {
                Matcher castMatcher = CAST_PATTERN.matcher(value);
                if (castMatcher.find()) {
                    type = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
                }
                itemClass.addField(fieldName, type);
            }
        }

        outputClass.addField(collectionField, "List<" + itemClassName + ">");

        StringBuilder loop = new StringBuilder();
        String counterVar = detectCounterVariable(body, variables);
        String counterStart = counterVar != null && variables.containsKey(counterVar) ? variables.get(counterVar).split(":")[1] : "0";

        loop.append("List<").append(itemClassName).append("> ").append(collectionField).append(" = new ArrayList<>();\n")
            .append("int ").append(counterVar != null ? counterVar.toLowerCase() : "counter").append(" = ").append(counterStart).append(";\n")
            .append("if (input.get").append(capitalize(collectionName)).append("() != null) {\n")
            .append("    for (").append(itemClassName).append(" ").append(refName.toLowerCase()).append(" : input.get").append(capitalize(collectionName)).append("()) {\n")
            .append("        ").append(itemClassName).append(" outputItem = new ").append(itemClassName).append("();\n")
            .append(convertLoopBodyWithCounter(body, refName.toLowerCase(), "outputItem", counterVar, references, variables))
            .append("        ").append(collectionField).append(".add(outputItem);\n")
            .append("        ").append(counterVar != null ? counterVar.toLowerCase() : "counter").append("++;\n")
            .append("    }\n")
            .append("}\n")
            .append("output.set").append(capitalize(collectionField)).append("(").append(collectionField).append(");");

        logicBlocks.add(loop.toString());
    }

    private static void processCreateLastChild(String parentPath, List<String> logicBlocks,
            Map<String, ClassStructure> classes, ClassStructure outputClass, ClassStructure envClass, Map<String, String> references) {
        String resolvedPath = resolveReference(parentPath, references);
        ClassStructure targetClass = resolvedPath.startsWith("Environment") ? envClass : outputClass;

        String[] parts = resolvedPath.split("\\.");
        String fieldName = parts[parts.length - 1].toLowerCase();
        targetClass.addField(fieldName, capitalize(fieldName));

        StringBuilder create = new StringBuilder();
        String root = resolvedPath.startsWith("Environment") ? "environment" : "output";
        create.append(root).append(".set").append(capitalize(fieldName)).append("(new ").append(capitalize(fieldName)).append("());\n");

        logicBlocks.add(create.toString());
    }

    private static void processCreateField(String parentPath, String fieldName, String typeName, List<String> logicBlocks,
            Map<String, ClassStructure> classes, ClassStructure outputClass, ClassStructure envClass, Map<String, String> references) {
        String resolvedPath = resolveReference(parentPath, references);
        ClassStructure targetClass;
        String root;

        if (resolvedPath.startsWith("Environment")) {
            targetClass = envClass;
            root = "environment";
        } else {
            targetClass = outputClass;
            root = "output";
        }

        String[] parts = resolvedPath.split("\\.");
        String className = parts.length > 2 ? capitalize(parts[2].replace("*:", "")) : targetClass.name;
        ClassStructure nestedClass = classes.computeIfAbsent(className, ClassStructure::new);
        String javaType = typeName != null ? TYPE_MAPPING.getOrDefault(typeName.toUpperCase(), "String") : "String";

        nestedClass.addField(fieldName.toLowerCase(), javaType);
        if (!className.equals(targetClass.name)) {
            targetClass.addField(parts[2].replace("*:", "").toLowerCase(), className);
        }

        String setter = root + ".get" + className + "().set" + capitalize(fieldName) + "(null);";
        logicBlocks.add(setter);
    }

    private static String generateSetter(String outputPath, String outputField, String value, Map<String, String> references,
            String castType, String coalesceValue, String defaultValue, Matcher headerMatcher, String iterator) {
        String root = outputPath.startsWith("Environment") ? "environment" : "output";
        String[] parts = outputPath.split("\\.");
        StringBuilder setterPath = new StringBuilder(root);

        for (int i = 1; i < parts.length - 1; i++) {
            if (!parts[i].equals("MRM") && !parts[i].equals("DFDL")) {
                String fieldName = parts[i].replace("*:", "").toLowerCase();
                String capitalizedField = capitalize(fieldName);
                setterPath.append(".get").append(capitalizedField).append("() == null ? new ").append(capitalizedField).append("() : ")
                          .append(".set").append(capitalizedField).append("(new ").append(capitalizedField).append("());\n");
                setterPath.append(root);
                for (int j = 1; j <= i; j++) {
                    if (!parts[j].equals("MRM") && !parts[j].equals("DFDL")) {
                        setterPath.append(".get").append(capitalize(parts[j].replace("*:", ""))).append("()");
                    }
                }
            }
        }

        Matcher dateMatcher = DATE_PATTERN.matcher(value);
        if (dateMatcher.find()) {
            String dateExpr = dateMatcher.group(1);
            String format = dateMatcher.group(2);
            String javaFormat = convertDateFormat(format);
            String resolvedDateExpr = resolveReference(dateExpr, references);
            String dateValue = resolvedDateExpr.contains("InputRoot") ? buildInputGetter(resolvedDateExpr, iterator) : convertValue(resolvedDateExpr);
            return setterPath + ".set" + capitalize(outputField) + "(LocalDateTime.parse(" + dateValue + ", DateTimeFormatter.ofPattern(\"" + javaFormat + "\")));";
        }

        headerMatcher.reset(value);
        if (headerMatcher.find() && references.containsKey(headerMatcher.group(1)) && references.get(headerMatcher.group(1)).contains("HTTPRequestHeader")) {
            String headerKey = headerMatcher.group(2).toLowerCase();
            return setterPath + ".set" + capitalize(outputField) + "(headersMap.get(\"" + headerKey + "\"));";
        }

        String resolvedValue = resolveReference(value, references);
        Matcher inputMatcher = INPUT_PATTERN.matcher(resolvedValue);
        if (inputMatcher.find()) {
            String inputGetter = buildInputGetter(resolvedValue, iterator);
            if (coalesceValue != null) {
                String coalesceExpression = "Optional.ofNullable(" + inputGetter + ").orElse(" + defaultValue + ")";
                if (castType != null) {
                    coalesceExpression = applyCasting(coalesceExpression, castType);
                }
                return setterPath + ".set" + capitalize(outputField) + "(" + coalesceExpression + ");";
            } else if (castType != null) {
                String castExpression = applyCasting(inputGetter, castType);
                return setterPath + ".set" + capitalize(outputField) + "(" + castExpression + ");";
            } else {
                return setterPath + ".set" + capitalize(outputField) + "(" + inputGetter + ");";
            }
        }

        Matcher substringMatcher = SUBSTRING_PATTERN.matcher(value);
        if (substringMatcher.find()) {
            String expr = substringMatcher.group(1);
            String operation = substringMatcher.group(2);
            String delimiter = substringMatcher.group(3);
            String subExpr = expr.contains("InputRoot") ? buildInputGetter(expr, iterator) : convertValue(expr);
            String substringExpr = "AFTER".equals(operation) ? subExpr + ".substring(" + subExpr + ".indexOf(\"" + delimiter + "\") + 1)" : subExpr + ".substring(0, " + subExpr + ".indexOf(\"" + delimiter + "\"))";
            return setterPath + ".set" + capitalize(outputField) + "(" + substringExpr + ");";
        }

        return setterPath + ".set" + capitalize(outputField) + "(" + convertValue(value) + ");";
    }

    private static String buildInputGetter(String resolvedValue, String iterator) {
        String[] inputParts = resolvedValue.split("\\.");
        StringBuilder inputGetter = new StringBuilder(iterator != null ? iterator : "input");
        int startIndex = resolvedValue.contains("MRM") || resolvedValue.contains("DFDL") ? 2 : resolvedValue.contains("MQRFH2") ? 1 : 3;

        for (int i = startIndex; i < inputParts.length - 1; i++) {
            if (!inputParts[i].equals("MRM") && !inputParts[i].equals("DFDL") && !inputParts[i].equals("JSON") && !inputParts[i].equals("Data") && !inputParts[i].equals("MQRFH2") && !inputParts[i].equals("usr")) {
                if (inputParts[i].matches("Item\\[\\d+\\]")) {
                    int index = Integer.parseInt(inputParts[i].replaceAll(".*?\\[(\\d+)\\]", "$1")) - 1;
                    inputGetter.append(".getItem().get(").append(index).append(")");
                } else {
                    inputGetter.append(".get").append(capitalize(inputParts[i].replace("*:", ""))).append("()");
                }
            }
        }
        inputGetter.append(".get").append(capitalize(inputParts[inputParts.length - 1].replace("*:", ""))).append("()");
        return inputGetter.toString();
    }

    private static String resolveReference(String path, Map<String, String> references) {
        if (references.containsKey(path)) {
            return references.get(path);
        }
        for (Map.Entry<String, String> entry : references.entrySet()) {
            if (path.startsWith(entry.getKey() + ".")) {
                return entry.getValue() + path.substring(entry.getKey().length());
            }
        }
        return path;
    }

    private static String extractCollectionName(String path, boolean isForLoop) {
        String[] parts = path.split("\\.");
        if (isForLoop) {
            for (int i = parts.length - 1; i >= 0; i--) {
                if (parts[i].startsWith("*:") && !parts[i].equals("*:item")) {
                    return parts[i].replace("*:", "").toLowerCase();
                }
            }
        } else {
            for (int i = parts.length - 1; i >= 0; i--) {
                if (parts[i].startsWith("*:") && !parts[i].matches("Item\\[.*?\\]")) {
                    return parts[i].replace("*:", "").toLowerCase();
                }
            }
        }
        return parts[parts.length - 1].replace("*:", "").toLowerCase();
    }

    private static void processPath(String fullPath, Map<String, ClassStructure> classes, ClassStructure rootClass,
            boolean isOutput, String value) {
        String[] parts = fullPath.split("\\.");
        if (parts.length < 2) {
            return;
        }

        if (fullPath.startsWith("Environment")) {
            processEnvironmentPath(fullPath, classes, rootClass, value);
        } else if (fullPath.contains("MRM") || fullPath.contains("DFDL")) {
            processDomainPath(fullPath, classes, rootClass, isOutput, value);
        } else if (fullPath.contains("JSON.Data")) {
            processJsonPath(fullPath, classes, rootClass, isOutput, value);
        } else if (fullPath.contains("MQRFH2")) {
            String fieldName = parts[parts.length - 1].replace("*:", "").toLowerCase();
            String type = determineFieldType(fieldName, fullPath, value);
            rootClass.addField(fieldName, type);
        }
    }

    private static void processJsonPath(String fullPath, Map<String, ClassStructure> classes, ClassStructure rootClass,
            boolean isOutput, String value) {
        String[] parts = fullPath.split("\\.");
        ClassStructure currentClass = rootClass;
        int startIndex = 3; // Start after "InputRoot.JSON.Data"

        for (int i = startIndex; i < parts.length - 1; i++) {
            if (parts[i].matches("Item\\[\\d+\\]")) {
                String fieldName = parts[i - 1].replace("*:", "").toLowerCase();
                String itemClassName = capitalize(fieldName.replaceAll("s$", ""));
                currentClass.addField(fieldName, "List<" + itemClassName + ">");
                currentClass = classes.computeIfAbsent(itemClassName, ClassStructure::new);
            } else if (!parts[i].equals("JSON") && !parts[i].equals("Data")) {
                String fieldName = parts[i].replace("*:", "").toLowerCase();
                String nextClassName = capitalize(fieldName.replaceAll("s$", ""));
                if (i == parts.length - 2 && !parts[i + 1].matches("Item\\[.*?\\]")) {
                    String type = determineFieldType(fieldName, fullPath, value);
                    currentClass.addField(fieldName, type);
                } else {
                    currentClass.addField(fieldName, nextClassName);
                    currentClass = classes.computeIfAbsent(nextClassName, ClassStructure::new);
                }
            }
        }
        if (!parts[parts.length - 1].matches("Item\\[.*?\\]")) {
            String fieldName = parts[parts.length - 1].replace("*:", "").toLowerCase();
            String type = determineFieldType(fieldName, fullPath, value);
            currentClass.addField(fieldName, type);
        }
    }

    private static void processEnvironmentPath(String fullPath, Map<String, ClassStructure> classes, ClassStructure rootClass, String value) {
        String[] parts = fullPath.split("\\.");
        ClassStructure currentClass = rootClass;
        int startIndex = 1; // Start after "Environment"

        for (int i = startIndex; i < parts.length - 1; i++) {
            String fieldName = parts[i].replace("*:", "").toLowerCase();
            String nextClassName = capitalize(fieldName.replaceAll("s$", ""));
            if (i == parts.length - 2 && !parts[i + 1].matches("Item\\[.*?\\]")) {
                String type = determineFieldType(fieldName, fullPath, value);
                currentClass.addField(fieldName, type);
            } else {
                ClassStructure nestedClass = classes.computeIfAbsent(nextClassName, ClassStructure::new);
                currentClass.addField(fieldName, nextClassName);
                currentClass = nestedClass;
            }
        }
        if (!parts[parts.length - 1].matches("Item\\[.*?\\]")) {
            String fieldName = parts[parts.length - 1].replace("*:", "").toLowerCase();
            String type = determineFieldType(fieldName, fullPath, value);
            currentClass.addField(fieldName, type);
        }
    }

    private static void processDomainPath(String fullPath, Map<String, ClassStructure> classes, ClassStructure rootClass,
            boolean isOutput, String value) {
        String[] parts = fullPath.split("\\.");
        ClassStructure currentClass = rootClass;
        int startIndex = fullPath.contains("JSON.Data") ? 3 : 2;

        for (int i = startIndex; i < parts.length - 1; i++) {
            if (!parts[i].equals("MRM") && !parts[i].equals("DFDL") && !parts[i].equals("JSON") && !parts[i].equals("Data")) {
                String fieldName = parts[i].replace("*:", "").toLowerCase();
                String nextClassName = capitalize(fieldName);
                if (i == parts.length - 2 && !parts[i + 1].matches("Item\\[.*?\\]")) {
                    String type = determineFieldType(fieldName, fullPath, value);
                    currentClass.addField(fieldName, nextClassName);
                    currentClass = classes.computeIfAbsent(nextClassName, ClassStructure::new);
                    currentClass.addField(fieldName, type);
                } else {
                    ClassStructure nestedClass = classes.computeIfAbsent(nextClassName, ClassStructure::new);
                    currentClass.addField(fieldName, nextClassName);
                    currentClass = nestedClass;
                }
            }
        }
        if (!parts[parts.length - 1].matches("Item\\[.*?\\]")) {
            String fieldName = parts[parts.length - 1].replace("*:", "").toLowerCase();
            String type = determineFieldType(fieldName, fullPath, value);
            currentClass.addField(fieldName, type);
        }
    }

    private static void processArrayPath(String fullPath, String fieldName, Map<String, ClassStructure> classes,
            ClassStructure rootClass, boolean isOutput, String value) {
        String[] parts = fullPath.split("\\.");
        ClassStructure currentClass = rootClass;
        int startIndex = fullPath.contains("JSON.Data") ? 3 : 2;

        for (int i = startIndex; i < parts.length - 1; i++) {
            if (!parts[i].equals("MRM") && !parts[i].equals("DFDL") && !parts[i].equals("JSON") && !parts[i].equals("Data")) {
                String field = parts[i].replace("*:", "").toLowerCase();
                String nextClassName = capitalize(field);
                ClassStructure nestedClass = classes.computeIfAbsent(nextClassName, ClassStructure::new);
                currentClass.addField(field, nextClassName);
                currentClass = nestedClass;
            }
        }

        String arrayField = parts[parts.length - 1].toLowerCase();
        String itemClassName = capitalize(arrayField);
        ClassStructure itemClass = classes.computeIfAbsent(itemClassName, ClassStructure::new);
        currentClass.addField(arrayField, "List<" + itemClassName + ">");
        itemClass.addField(fieldName.toLowerCase(), determineFieldType(fieldName.toLowerCase(), fullPath, value));
    }

    private static void generateModelClasses(Map<String, Object> parseResult) throws IOException {
        Map<String, ClassStructure> classes = (Map<String, ClassStructure>) parseResult.get("classes");

        for (ClassStructure cls : classes.values()) {
            if (cls.name.isEmpty() || cls.fields.isEmpty()) continue;
            StringBuilder content = new StringBuilder()
                .append("package ").append(MODEL_PACKAGE).append(";\n\n")
                .append("import lombok.Data;\n")
                .append("import java.util.List;\n")
                .append("import java.time.LocalDateTime;\n\n")
                .append("@Data\n")
                .append("public class ").append(cls.name).append(" {\n");

            for (Map.Entry<String, String> field : cls.fields.entrySet()) {
                content.append("    private ").append(field.getValue()).append(" ").append(field.getKey()).append(";\n");
            }
            content.append("}\n");
            writeToFile(OUTPUT_DIR + cls.name + ".java", content.toString());
        }
    }

    private static void generateMapperClass(Map<String, Object> parseResult) throws IOException {
        List<String> logicBlocks = (List<String>) parseResult.get("logicBlocks");
        Map<String, List<String>> procedureBlocks = (Map<String, List<String>>) parseResult.get("procedureBlocks");
        Set<String> headerKeys = (Set<String>) parseResult.get("headerKeys");

        StringBuilder mapper = new StringBuilder()
            .append("package ").append(MAPPER_PACKAGE).append(";\n\n")
            .append("import ").append(MODEL_PACKAGE).append(".*;\n")
            .append("import java.util.*;\n")
            .append("import java.util.stream.Collectors;\n")
            .append("import java.util.stream.Stream;\n")
            .append("import java.time.LocalDateTime;\n")
            .append("import java.time.format.DateTimeFormatter;\n\n")
            .append("public class DataMapper {\n");

        for (Map.Entry<String, List<String>> entry : procedureBlocks.entrySet()) {
            String methodName = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);
            mapper.append("    private void ").append(methodName).append("(Input input, Output output, Environment environment, Map<String, String> headersMap) {\n");
            for (String block : entry.getValue()) {
                mapper.append("        ").append(block).append("\n");
            }
            mapper.append("    }\n\n");
        }

        mapper.append("    public Output map(Input input, Map<String, String> headers, String requestIdentifier) {\n")
            .append("        Map<String, String> headersMap = new HashMap<>();\n");

        for (String key : headerKeys) {
            mapper.append("        headersMap.put(\"").append(key).append("\", headers.get(\"").append(key).append("\"));\n");
        }

        mapper.append("        Output output = new Output();\n")
              .append("        Environment environment = new Environment();\n");

        for (String block : logicBlocks) {
            mapper.append("        ").append(block).append("\n");
        }

        for (String procName : procedureBlocks.keySet()) {
            String methodName = procName.substring(0, 1).toLowerCase() + procName.substring(1);
            mapper.append("        ").append(methodName).append("(input, output, environment, headersMap);\n");
        }

        mapper.append("        return output;\n")
            .append("    }\n")
            .append("}\n");

        writeToFile(OUTPUT_DIR + "DataMapper.java", mapper.toString());
    }

    static class ClassStructure {
        String name;
        Map<String, String> fields = new LinkedHashMap<>();

        ClassStructure(String name) {
            this.name = name;
        }

        void addField(String name, String type) {
            fields.putIfAbsent(name, type);
        }
    }

    private static String determineFieldType(String fieldName, String fullPath, String value) {
        if (value != null) {
            if (fieldName.toLowerCase().contains("date") || fieldName.toLowerCase().contains("time")) {
                return "LocalDateTime";
            }
            if (value.matches("'true'|'false'|TRUE|FALSE")) return "String";
            if (value.matches("\\d+")) return "Integer";
            if (value.startsWith("'") && value.endsWith("'")) return "String";
            if (!value.contains("InputRoot")) return "String";
        }
        return "String";
    }

    private static String capitalize(String str) {
        if (str == null || str.isEmpty()) return str;
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }

    private static String convertValue(String value) {
        if (value.startsWith("'") && value.endsWith("'")) {
            String val = value.substring(1, value.length() - 1);
            if ("true".equalsIgnoreCase(val) || "false".equalsIgnoreCase(val)) return "\"" + val.toUpperCase() + "\"";
            return "\"" + val + "\"";
        }
        if ("TRUE".equalsIgnoreCase(value)) return "\"TRUE\"";
        if ("FALSE".equalsIgnoreCase(value)) return "\"FALSE\"";
        return value;
    }

    private static String convertValue(String value, Map<String, String> references, String iterator) {
        String resolvedValue = resolveReference(value, references);
        Matcher inputMatcher = INPUT_PATTERN.matcher(resolvedValue);
        if (inputMatcher.find()) {
            return buildInputGetter(resolvedValue, iterator);
        }
        return convertValue(value);
    }

    private static String applyCasting(String expression, String javaType) {
        switch (javaType) {
            case "Integer": return "Integer.parseInt(" + expression + ")";
            case "Float": return "Float.parseFloat(" + expression + ")";
            case "Double": return "Double.parseDouble(" + expression + ")";
            case "Boolean": return "Boolean.parseBoolean(" + expression + ")";
            case "String": return "String.valueOf(" + expression + ")";
            default: return expression;
        }
    }

    private static String convertLoopBodyWithCounter(String body, String iterator, String itemVar, String counterVar,
            Map<String, String> references, Map<String, String> variables) {
        StringBuilder result = new StringBuilder();
        int lastPos = 0;

        Matcher setMatcher = LOOP_INDEX_PATTERN.matcher(body);
        Matcher ifMatcher = IF_PATTERN.matcher(body);

        while (lastPos < body.length()) {
            int nextSetPos = setMatcher.find(lastPos) ? setMatcher.start() : Integer.MAX_VALUE;
            int nextIfPos = ifMatcher.find(lastPos) ? ifMatcher.start() : Integer.MAX_VALUE;

            if (nextSetPos == Integer.MAX_VALUE && nextIfPos == Integer.MAX_VALUE) {
                break;
            }

            if (nextSetPos < nextIfPos) {
                String field = setMatcher.group(3).toLowerCase();
                String value = setMatcher.group(4).trim();
                String resolvedValue = resolveReference(value, references);

                if (field.equals("httpcode") || field.equals("httpmessage") || field.equals("moreinformation")
                        || resolvedValue.contains("httpCode") || resolvedValue.contains("httpMessage")
                        || resolvedValue.contains("moreInformation")) {
                    lastPos = setMatcher.end();
                    continue;
                }

                String setter;
                Matcher castMatcher = CAST_PATTERN.matcher(value);
                Matcher coalesceMatcher = COALESCE_PATTERN.matcher(value);
                Matcher dateMatcher = DATE_PATTERN.matcher(value);
                if (coalesceMatcher.find()) {
                    String[] args = coalesceMatcher.group(1).split(",");
                    String coalesceValue = args[0].trim();
                    String defaultValue = args.length > 1 ? args[1].trim().replaceAll("'", "\"") : "\"\"";
                    String inputGetter = buildInputGetter(resolveReference(coalesceValue, references), iterator);
                    setter = itemVar + ".set" + capitalize(field) + "(Optional.ofNullable(" + inputGetter + ").orElse(" + defaultValue + "));";
                } else if (castMatcher.find()) {
                    String castExpr = castMatcher.group(1).trim();
                    String castType = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
                    String inputGetter = buildInputGetter(resolveReference(castExpr, references), iterator);
                    setter = itemVar + ".set" + capitalize(field) + "(" + applyCasting(inputGetter, castType) + ");";
                } else if (dateMatcher.find()) {
                    String dateExpr = dateMatcher.group(1);
                    String format = dateMatcher.group(2);
                    String javaFormat = convertDateFormat(format);
                    String resolvedDateExpr = resolveReference(dateExpr, references);
                    String dateValue = resolvedDateExpr.contains("InputRoot") ? buildInputGetter(resolvedDateExpr, iterator) : convertValue(resolvedDateExpr);
                    setter = itemVar + ".set" + capitalize(field) + "(LocalDateTime.parse(" + dateValue + ", DateTimeFormatter.ofPattern(\"" + javaFormat + "\")));";
                } else {
                    String inputGetter = buildInputGetter(resolvedValue, iterator);
                    setter = itemVar + ".set" + capitalize(field) + "(" + inputGetter + ");";
                }
                result.append("        ").append(setter).append("\n");
                lastPos = setMatcher.end();
            } else {
                String condition = ifMatcher.group(1).trim();
                String thenBlock = ifMatcher.group(2).trim();
                String elseBlock = ifMatcher.group(3) != null ? ifMatcher.group(3).trim() : null;

                String resolvedCondition = resolveReference(condition, references);
                String conditionExpr = convertCondition(resolvedCondition, iterator, references);

                StringBuilder ifBlock = new StringBuilder();
                ifBlock.append("        if (").append(conditionExpr).append(") {\n");

                Matcher thenSetter = LOOP_INDEX_PATTERN.matcher(thenBlock);
                while (thenSetter.find()) {
                    String field = thenSetter.group(3).toLowerCase();
                    String value = thenSetter.group(4).trim();
                    String resolvedValue = resolveReference(value, references);

                    if (field.equals("httpcode") || field.equals("httpmessage") || field.equals("moreinformation")
                            || resolvedValue.contains("httpCode") || resolvedValue.contains("httpMessage")
                            || resolvedValue.contains("moreInformation")) {
                        continue;
                    }

                    String setter;
                    Matcher castMatcher = CAST_PATTERN.matcher(value);
                    Matcher coalesceMatcher = COALESCE_PATTERN.matcher(value);
                    if (coalesceMatcher.find()) {
                        String[] args = coalesceMatcher.group(1).split(",");
                        String coalesceValue = args[0].trim();
                        String defaultValue = args.length > 1 ? args[1].trim().replaceAll("'", "\"") : "\"\"";
                        String inputGetter = buildInputGetter(resolveReference(coalesceValue, references), iterator);
                        setter = itemVar + ".set" + capitalize(field) + "(Optional.ofNullable(" + inputGetter + ").orElse(" + defaultValue + "));";
                    } else if (castMatcher.find()) {
                        String castExpr = castMatcher.group(1).trim();
                        String castType = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
                        String inputGetter = buildInputGetter(resolveReference(castExpr, references), iterator);
                        setter = itemVar + ".set" + capitalize(field) + "(" + applyCasting(inputGetter, castType) + ");";
                    } else {
                        String inputGetter = buildInputGetter(resolvedValue, iterator);
                        setter = itemVar + ".set" + capitalize(field) + "(" + convertValue(resolvedValue) + ");";
                    }
                    ifBlock.append("            ").append(setter).append("\n");
                }

                if (elseBlock != null) {
                    ifBlock.append("        } else {\n");
                    Matcher elseSetter = LOOP_INDEX_PATTERN.matcher(elseBlock);
                    while (elseSetter.find()) {
                        String field = elseSetter.group(3).toLowerCase();
                        String value = elseSetter.group(4).trim();
                        String resolvedValue = resolveReference(value, references);

                        if (field.equals("httpcode") || field.equals("httpmessage") || field.equals("moreinformation")
                                || resolvedValue.contains("httpCode") || resolvedValue.contains("httpMessage")
                                || resolvedValue.contains("moreInformation")) {
                            continue;
                        }

                        String setter;
                        Matcher castMatcher = CAST_PATTERN.matcher(value);
                        Matcher coalesceMatcher = COALESCE_PATTERN.matcher(value);
                        if (coalesceMatcher.find()) {
                            String[] args = coalesceMatcher.group(1).split(",");
                            String coalesceValue = args[0].trim();
                            String defaultValue = args.length > 1 ? args[1].trim().replaceAll("'", "\"") : "\"\"";
                            String inputGetter = buildInputGetter(resolveReference(coalesceValue, references), iterator);
                            setter = itemVar + ".set" + capitalize(field) + "(Optional.ofNullable(" + inputGetter + ").orElse(" + defaultValue + "));";
                        } else if (castMatcher.find()) {
                            String castExpr = castMatcher.group(1).trim();
                            String castType = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
                            String inputGetter = buildInputGetter(resolveReference(castExpr, references), iterator);
                            setter = itemVar + ".set" + capitalize(field) + "(" + applyCasting(inputGetter, castType) + ");";
                        } else {
                            setter = itemVar + ".set" + capitalize(field) + "(" + convertValue(resolvedValue) + ");";
                        }
                        ifBlock.append("            ").append(setter).append("\n");
                    }
                }
                ifBlock.append("        }\n");

                result.append(ifBlock);
                lastPos = ifMatcher.end();
            }
        }

        return result.toString();
    }

    private static String convertCondition(String condition, String iterator, Map<String, String> references) {
        String resolvedCondition = resolveReference(condition, references);
        Matcher inputMatcher = INPUT_PATTERN.matcher(resolvedCondition);
        if (inputMatcher.find()) {
            String inputGetter = buildInputGetter(resolvedCondition, iterator);
            if (condition.contains("=")) {
                String[] parts = condition.split("=");
                String value = parts[1].trim();
                return inputGetter + ".equals(" + convertValue(value) + ")";
            }
            return inputGetter;
        }
        return convertValue(condition);
    }

    private static String detectCounterVariable(String body, Map<String, String> variables) {
        Matcher matcher = LOOP_INDEX_PATTERN.matcher(body);
        while (matcher.find()) {
            String indexVar = matcher.group(2);
            if (variables.containsKey(indexVar)) {
                return indexVar;
            }
        }
        return null;
    }

    private static String extractOutputCollection(String body, Map<String, String> references, String inputCollectionName) {
        Matcher matcher = LOOP_INDEX_PATTERN.matcher(body);
        if (matcher.find()) {
            String rawPath = matcher.group(1).trim();
            String resolvedPath = resolveReference(rawPath, references);
            if (!resolvedPath.matches("(OutputRoot\\.(JSON\\.Data|MRM|DFDL)|Environment).*")) {
                resolvedPath = "OutputRoot.JSON.Data." + resolvedPath;
            }
            return resolvedPath;
        }
        return "OutputRoot.JSON.Data." + inputCollectionName;
    }

    private static boolean isWithinProcedure(int position, Matcher procedureMatcher) {
        procedureMatcher.reset();
        while (procedureMatcher.find()) {
            if (position >= procedureMatcher.start() && position <= procedureMatcher.end()) {
                return true;
            }
        }
        return false;
    }

    private static void writeToFile(String filePath, String content) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath, StandardCharsets.UTF_8))) {
            writer.write(content);
        }
    }

    private static String convertDateFormat(String esqlFormat) {
        return esqlFormat.replace("%Y", "yyyy").replace("%y", "yy").replace("%m", "MM").replace("%d", "dd")
                .replace("%H", "HH").replace("%h", "hh").replace("%M", "mm").replace("%S", "ss")
                .replace("%f", "SSS").replace("%a", "EEE").replace("%A", "EEEE").replace("%b", "MMM")
                .replace("%B", "MMMM").replace("%p", "a").replace("%z", "Z").replace("%Z", "z");
    }
}
