package complexesqloJava;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class EsqlToJavaConverter {

    private static final String OUTPUT_DIR = "generated/";
    private static final String MODEL_PACKAGE = "com.example.model";
    private static final String MAPPER_PACKAGE = "com.example.mapper";

    private static final Map<String, String> TYPE_MAPPING = new HashMap<>();
    static {
        TYPE_MAPPING.put("INTEGER", "Integer");
        TYPE_MAPPING.put("FLOAT", "Float");
        TYPE_MAPPING.put("DECIMAL", "Double");
        TYPE_MAPPING.put("CHARACTER", "String");
        TYPE_MAPPING.put("BOOLEAN", "Boolean");
    }

    private static final Pattern PROCEDURE_PATTERN = Pattern.compile("CREATE\\s+PROCEDURE\\s+(\\w+)\\s*\\(\\s*\\)\\s*BEGIN\\s+(.+?)\\s+END\\s*;", Pattern.DOTALL);
    private static final Pattern ASSIGNMENT_PATTERN = Pattern.compile("SET\\s+([^=]+)\\s*=\\s*([^;]+);", Pattern.DOTALL);
    private static final Pattern INPUT_PATTERN = Pattern.compile("(InputRoot\\.(?:JSON\\.Data|XML|XMLNSC|MRM|DFDL)(?:\\.\\*:?\\w+)*(?:\\.Item\\[.*?\\])?)\\.([\\w*:]+)", Pattern.DOTALL);
    private static final Pattern HEADER_PATTERN = Pattern.compile("([^\\.]+)\\.\"([^\"]+)\"", Pattern.DOTALL);
    private static final Pattern CAST_PATTERN = Pattern.compile("CAST\\(([^)]+)\\s+AS\\s+(\\w+)\\)", Pattern.DOTALL);
    private static final Pattern COALESCE_PATTERN = Pattern.compile("COALESCE\\(([^,]+(?:,[^,]+)*)\\)", Pattern.DOTALL);
    private static final Pattern FOR_PATTERN = Pattern.compile("FOR\\s+(\\w+)\\s+AS\\s+([^)]+)\\s+DO\\s+(.+?)\\s+END FOR", Pattern.DOTALL);
    private static final Pattern WHILE_PATTERN = Pattern.compile("WHILE\\s+(.+?)\\s+DO\\s+(.+?)\\s+END WHILE", Pattern.DOTALL);
    private static final Pattern REFERENCE_PATTERN = Pattern.compile("DECLARE\\s+(\\w+)\\s+REFERENCE\\s+TO\\s+([^;]+);", Pattern.DOTALL);
    private static final Pattern DECLARE_PATTERN = Pattern.compile("DECLARE\\s+(\\w+)\\s+(INTEGER|FLOAT|DECIMAL|CHARACTER|BOOLEAN)(?:\\s+(\\d+|'.*?'))?;", Pattern.DOTALL);
    private static final Pattern SUBSTRING_PATTERN = Pattern.compile("SUBSTRING\\(([^)]+)\\s+(AFTER|BEFORE)\\s*'([^']*)'\\)", Pattern.DOTALL);
    private static final Pattern MOVE_PATTERN = Pattern.compile("MOVE\\s+(\\w+)\\s+(FIRSTCHILD|NEXTSIBLING);", Pattern.DOTALL);
    private static final Pattern DATE_PATTERN = Pattern.compile("DATE_FORMAT\\(([^,]+),\\s*'([^']+)'\\)", Pattern.DOTALL);
    private static final Pattern CREATE_LASTCHILD_PATTERN = Pattern.compile("CREATE\\s+LASTCHILD\\s+OF\\s+([^\\s]+)\\s+DOMAIN\\s*\\('([^']+)'\\);", Pattern.DOTALL);
    private static final Pattern CREATE_FIELD_PATTERN = Pattern.compile("CREATE\\s+FIELD\\s+([^\\s]+)\\.(\\w+)\\s*(?:TYPE\\s+NAME\\s+(\\w+))?;", Pattern.DOTALL);
    private static final Pattern LOOP_INDEX_PATTERN = Pattern.compile("SET\\s+([^=]+)\\.Item\\[(\\w+)\\]\\.(\\w+)\\s*=\\s*([^;]+);", Pattern.DOTALL);
    private static final Pattern IF_PATTERN = Pattern.compile("IF\\s+(.+?)\\s+THEN\\s+(.+?)\\s+(?:ELSE\\s+(.+?)\\s+)?END\\s+IF", Pattern.DOTALL);
    private static final Pattern INCOMPLETE_SET_PATTERN = Pattern.compile("(?:SET\\s+)?([^=]+)\\s*=\\s*([^;]+);", Pattern.DOTALL);
    private static final Pattern MISSING_SET_PATTERN = Pattern.compile("([^=]+\\s+[^;]+);", Pattern.DOTALL);

    // Track arrays that need initialization at the start
    private static final Set<String> arraysToInitialize = new HashSet<>();

    // Global set to track initialized paths across all SET statements
    private static final Set<String> initializedPaths = new HashSet<>();

    // Static references to inputClass, outputClass, and envClass for use across methods
    private static ClassStructure inputClass;
    private static ClassStructure outputClass;
    private static ClassStructure envClass;

    // Flag to track if the input is a JSON stream
    private static boolean isJsonStream = false;

    public static void main(String[] args) {
        String esqlFilePath = args.length > 0 ? args[0] : "input.esql";
        try {
            String esqlScript = readEsqlFromFile(esqlFilePath);
            new File(OUTPUT_DIR).mkdirs();
            Map<String, Object> parseResult = parseEsqlScript(esqlScript);
            generateModelClasses(parseResult);
            generateMapperClass(parseResult);
            System.out.println("Conversion completed successfully. Files generated in " + OUTPUT_DIR);
        } catch (Exception e) {
            System.err.println("Error during conversion: " + e.getMessage());
            e.printStackTrace();
        } finally {
            initializedPaths.clear();
            arraysToInitialize.clear();
            isJsonStream = false;
        }
    }

    private static String readEsqlFromFile(String filePath) throws IOException {
        StringBuilder content = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
        }
        return content.toString();
    }

    private static Map<String, Object> parseEsqlScript(String esqlScript) {
        Map<String, Object> result = new HashMap<>();
        Map<String, ClassStructure> classes = new HashMap<>();
        List<String> logicBlocks = new ArrayList<>();
        Map<String, List<String>> procedureBlocks = new HashMap<>();
        Map<String, String> references = new HashMap<>();
        Map<String, String> variables = new HashMap<>();
        Set<String> headerKeys = new HashSet<>();

        // Initialize static class structures
        inputClass = classes.computeIfAbsent("Input", ClassStructure::new);
        outputClass = classes.computeIfAbsent("Output", ClassStructure::new);
        envClass = classes.computeIfAbsent("Environment", ClassStructure::new);

        // Check if the script indicates JSON streaming (e.g., WHILE LASTMOVE on JSON.Data)
        if (esqlScript.contains("WHILE LASTMOVE") && esqlScript.contains("JSON.Data")) {
            isJsonStream = true;
        }

        // Parse DECLARE statements for variables
        Matcher declareMatcher = DECLARE_PATTERN.matcher(esqlScript);
        while (declareMatcher.find()) {
            String varName = declareMatcher.group(1);
            String varType = TYPE_MAPPING.getOrDefault(declareMatcher.group(2).toUpperCase(), "String");
            String varValue = declareMatcher.group(3) != null ? declareMatcher.group(3).replaceAll("'", "\"") : "null";
            variables.put(varName, varType + ":" + varValue);
        }

        // Parse DECLARE statements for references
        Matcher referenceMatcher = REFERENCE_PATTERN.matcher(esqlScript);
        while (referenceMatcher.find()) {
            references.put(referenceMatcher.group(1).trim(), referenceMatcher.group(2).trim());
        }

        // Parse PROCEDURE blocks
        Matcher procedureMatcher = PROCEDURE_PATTERN.matcher(esqlScript);
        while (procedureMatcher.find()) {
            String procedureName = procedureMatcher.group(1);
            String body = procedureMatcher.group(2);
            List<String> procLogic = new ArrayList<>();
            parseProcedureBody(body, procLogic, classes, references, headerKeys, variables);
            procedureBlocks.put(procedureName, procLogic);
        }

        // Parse ASSIGNMENT (SET) statements outside procedures
        Matcher assignmentMatcher = ASSIGNMENT_PATTERN.matcher(esqlScript);
        while (assignmentMatcher.find()) {
            if (!isWithinProcedure(assignmentMatcher.start(), procedureMatcher)) {
                processAssignment(assignmentMatcher.group(1).trim(), assignmentMatcher.group(2).trim(), logicBlocks,
                        classes, references, headerKeys, variables, null);
            }
        }

        // Parse incomplete SET statements (e.g., missing SET keyword or redundant SET)
        Matcher incompleteSetMatcher = INCOMPLETE_SET_PATTERN.matcher(esqlScript);
        while (incompleteSetMatcher.find()) {
            if (!isWithinProcedure(incompleteSetMatcher.start(), procedureMatcher)) {
                String outputPath = incompleteSetMatcher.group(1).trim();
                String value = incompleteSetMatcher.group(2).trim();
                if (!value.isEmpty()) { // Skip if value is empty
                    processAssignment(outputPath, value, logicBlocks, classes, references, headerKeys, variables, null);
                }
            }
        }

        // Parse statements missing SET keyword
        Matcher missingSetMatcher = MISSING_SET_PATTERN.matcher(esqlScript);
        while (missingSetMatcher.find()) {
            if (!isWithinProcedure(missingSetMatcher.start(), procedureMatcher)) {
                String statement = missingSetMatcher.group(1).trim();
                String[] parts = statement.split("\\s+");
                if (parts.length >= 2) {
                    String outputPath = parts[0].trim();
                    String value = String.join(" ", Arrays.copyOfRange(parts, 1, parts.length)).trim();
                    processAssignment(outputPath, value, logicBlocks, classes, references, headerKeys, variables, null);
                }
            }
        }

        // Parse FOR loops outside procedures
        Matcher forMatcher = FOR_PATTERN.matcher(esqlScript);
        while (forMatcher.find()) {
            if (!isWithinProcedure(forMatcher.start(), procedureMatcher)) {
                processForLoop(forMatcher.group(1), forMatcher.group(2), forMatcher.group(3), logicBlocks, classes,
                        references, variables, 0);
            }
        }

        // Parse WHILE loops outside procedures
        Matcher whileMatcher = WHILE_PATTERN.matcher(esqlScript);
        while (whileMatcher.find()) {
            if (!isWithinProcedure(whileMatcher.start(), procedureMatcher)) {
                processWhileLoop(whileMatcher.group(1), whileMatcher.group(2), esqlScript.substring(0, whileMatcher.start()),
                        logicBlocks, classes, references, variables);
            }
        }

        // Parse CREATE LASTCHILD statements
        Matcher createLastChildMatcher = CREATE_LASTCHILD_PATTERN.matcher(esqlScript);
        while (createLastChildMatcher.find()) {
            processCreateLastChild(createLastChildMatcher.group(1), createLastChildMatcher.group(2), logicBlocks, classes, references);
        }

        // Parse CREATE FIELD statements
        Matcher createFieldMatcher = CREATE_FIELD_PATTERN.matcher(esqlScript);
        while (createFieldMatcher.find()) {
            processCreateField(createFieldMatcher.group(1), createFieldMatcher.group(2), createFieldMatcher.group(3), logicBlocks, classes, references);
        }

        result.put("classes", classes);
        result.put("logicBlocks", logicBlocks);
        result.put("procedureBlocks", procedureBlocks);
        result.put("headerKeys", headerKeys);
        result.put("arraysToInitialize", arraysToInitialize);
        return result;
    }

    private static void parseProcedureBody(String body, List<String> procLogic, Map<String, ClassStructure> classes,
            Map<String, String> references, Set<String> headerKeys, Map<String, String> variables) {
        Matcher assignmentMatcher = ASSIGNMENT_PATTERN.matcher(body);
        while (assignmentMatcher.find()) {
            processAssignment(assignmentMatcher.group(1).trim(), assignmentMatcher.group(2).trim(), procLogic, classes,
                    references, headerKeys, variables, null);
        }

        Matcher incompleteSetMatcher = INCOMPLETE_SET_PATTERN.matcher(body);
        while (incompleteSetMatcher.find()) {
            String outputPath = incompleteSetMatcher.group(1).trim();
            String value = incompleteSetMatcher.group(2).trim();
            if (!value.isEmpty()) {
                processAssignment(outputPath, value, procLogic, classes, references, headerKeys, variables, null);
            }
        }

        Matcher forMatcher = FOR_PATTERN.matcher(body);
        while (forMatcher.find()) {
            processForLoop(forMatcher.group(1), forMatcher.group(2), forMatcher.group(3), procLogic, classes,
                    references, variables, 0);
        }

        Matcher whileMatcher = WHILE_PATTERN.matcher(body);
        while (whileMatcher.find()) {
            processWhileLoop(whileMatcher.group(1), whileMatcher.group(2), body.substring(0, whileMatcher.start()),
                    procLogic, classes, references, variables);
        }

        Matcher createLastChildMatcher = CREATE_LASTCHILD_PATTERN.matcher(body);
        while (createLastChildMatcher.find()) {
            processCreateLastChild(createLastChildMatcher.group(1), createLastChildMatcher.group(2), procLogic, classes, references);
        }

        Matcher createFieldMatcher = CREATE_FIELD_PATTERN.matcher(body);
        while (createFieldMatcher.find()) {
            processCreateField(createFieldMatcher.group(1), createFieldMatcher.group(2), createFieldMatcher.group(3), procLogic, classes, references);
        }
    }

    private static void processAssignment(String outputPath, String value, List<String> logicBlocks,
            Map<String, ClassStructure> classes, Map<String, String> references, Set<String> headerKeys,
            Map<String, String> variables, String iterator) {
        String resolvedOutputPath = resolveReference(outputPath, references);
        String resolvedValue = resolveReference(value, references);

        // Skip assignments involving httpCode, httpMessage, or moreInformation
        if (!resolvedOutputPath.matches("(OutputRoot\\.(JSON\\.Data|XMLNSC|MRM|DFDL)|Environment|OutBodyRef).*") || resolvedOutputPath.contains("httpCode")
                || resolvedOutputPath.contains("httpMessage") || resolvedOutputPath.contains("moreInformation")
                || resolvedValue.contains("httpCode") || resolvedValue.contains("httpMessage")
                || resolvedValue.contains("moreInformation")) {
            return;
        }

        String fullOutputPath = resolvedOutputPath;
        String castType = null;
        String coalesceValue = null;
        String defaultValue = null;

        // Handle CAST
        Matcher castMatcher = CAST_PATTERN.matcher(value);
        if (castMatcher.find()) {
            value = castMatcher.group(1).trim();
            castType = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
        }

        // Handle COALESCE
        Matcher coalesceMatcher = COALESCE_PATTERN.matcher(value);
        if (coalesceMatcher.find()) {
            String[] args = coalesceMatcher.group(1).split(",");
            coalesceValue = args[0].trim();
            defaultValue = args.length > 1 ? args[1].trim().replaceAll("'", "\"") : "\"\"";
            value = coalesceValue;
        }

        // Determine the target class (Output, Environment, or OutBodyRef)
        ClassStructure targetClass;
        if (resolvedOutputPath.startsWith("Environment")) {
            targetClass = envClass;
        } else if (resolvedOutputPath.startsWith("OutBodyRef")) {
            targetClass = outputClass;
        } else {
            targetClass = outputClass;
        }
        processPath(fullOutputPath, classes, targetClass, true, castType != null ? castType : value);

        // Process input paths
        Matcher inputMatcher = INPUT_PATTERN.matcher(value);
        while (inputMatcher.find()) {
            String inputPath = inputMatcher.group(1);
            String fieldName = inputMatcher.group(2).replace("*:", "");
            processPath(inputPath, classes, inputClass, false, null);
        }

        // Process headers
        Matcher headerMatcher = HEADER_PATTERN.matcher(value);
        if (headerMatcher.find() && references.containsKey(headerMatcher.group(1))) {
            String refPath = references.get(headerMatcher.group(1));
            if (refPath.contains("HTTPRequestHeader")) {
                String headerKey = headerMatcher.group(2).toLowerCase();
                headerKeys.add(headerKey);
            }
        }

        // Collect arrays that need initialization
        if (resolvedOutputPath.contains("[")) {
            String arrayPath = resolvedOutputPath.substring(0, resolvedOutputPath.lastIndexOf('['));
            arraysToInitialize.add(arrayPath);
        }

        // Generate setter for the assignment
        String[] outputParts = resolvedOutputPath.split("\\.");
        String outputField = outputParts[outputParts.length - 1].toLowerCase();
        String setter = generateSetter(resolvedOutputPath, outputField, value, references, castType, coalesceValue, defaultValue, headerMatcher, iterator);
        logicBlocks.add(setter);
    }

    private static void processForLoop(String iterator, String collectionPath, String body, List<String> logicBlocks,
            Map<String, ClassStructure> classes, Map<String, String> references, Map<String, String> variables, int nestingLevel) {
        if (body.contains("httpCode") || body.contains("httpMessage") || body.contains("moreInformation")) {
            return;
        }

        String resolvedCollectionPath = resolveReference(collectionPath, references);
        String fullCollectionPath = resolvedCollectionPath.startsWith("InputRoot") ? resolvedCollectionPath
                : "InputRoot.JSON.Data." + resolvedCollectionPath;
        String collectionName = extractCollectionName(fullCollectionPath, true);
        String itemClassName = capitalize(collectionName.replaceAll("s$", ""));
        ClassStructure itemClass = classes.computeIfAbsent(itemClassName, ClassStructure::new);

        ClassStructure parentClass = nestingLevel == 0 ? inputClass : classes.get(capitalize(extractCollectionName(resolveReference(collectionPath.split("\\.")[0], references), true).replaceAll("s$", "")));
        parentClass.addField(collectionName, isJsonStream ? "Stream<" + itemClassName + ">" : "List<" + itemClassName + ">");

        String outputCollectionPath = extractOutputCollection(body, references, collectionName);
        String[] outputParts = outputCollectionPath.split("\\.");
        String collectionField = outputParts[outputParts.length - 1].toLowerCase();

        Matcher bodyMatcher = LOOP_INDEX_PATTERN.matcher(body);
        while (bodyMatcher.find()) {
            String fieldName = bodyMatcher.group(3).toLowerCase();
            String value = bodyMatcher.group(4).trim();
            String type = determineFieldType(fieldName, outputCollectionPath, value);
            if (!fieldName.equals("httpcode") && !fieldName.equals("httpmessage") && !fieldName.equals("moreinformation")) {
                Matcher castMatcher = CAST_PATTERN.matcher(value);
                if (castMatcher.find()) {
                    type = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
                }
                itemClass.addField(fieldName, type);
            }
        }

        if (nestingLevel == 0) {
            outputClass.addField(collectionField, isJsonStream ? "Stream<" + itemClassName + ">" : "List<" + itemClassName + ">");
        }

        StringBuilder loop = new StringBuilder();
        String indent = "    ".repeat(nestingLevel + 1);
        String counterVar = detectCounterVariable(body, variables);
        String counterStart = counterVar != null && variables.containsKey(counterVar) ? variables.get(counterVar).split(":")[1] : "0";

        if (isJsonStream) {
            loop.append(indent).append("Stream<").append(itemClassName).append("> ").append(collectionField).append(" = ")
                .append(nestingLevel == 0 ? "input" : iterator).append(".get").append(capitalize(collectionName)).append("()\n")
                .append(indent).append("    .map(").append(iterator).append(" -> {\n")
                .append(indent).append("        ").append(itemClassName).append(" outputItem = new ").append(itemClassName).append("();\n")
                .append(convertLoopBodyWithCounter(body, iterator, "outputItem", counterVar, references, variables, classes, nestingLevel))
                .append(indent).append("        return outputItem;\n")
                .append(indent).append("    });\n");
        } else {
            loop.append(indent).append("List<").append(itemClassName).append("> ").append(collectionField).append(" = new ArrayList<>();\n")
                .append(indent).append("if (").append(nestingLevel == 0 ? "input" : iterator).append(".get").append(capitalize(collectionName)).append("() != null) {\n")
                .append(indent).append("    int ").append(counterVar != null ? counterVar.toLowerCase() : "counter").append(" = ").append(counterStart).append(";\n")
                .append(indent).append("    for (").append(itemClassName).append(" ").append(iterator).append(" : ").append(nestingLevel == 0 ? "input" : iterator).append(".get").append(capitalize(collectionName)).append("()) {\n")
                .append(indent).append("        ").append(itemClassName).append(" outputItem = new ").append(itemClassName).append("();\n")
                .append(convertLoopBodyWithCounter(body, iterator, "outputItem", counterVar, references, variables, classes, nestingLevel))
                .append(indent).append("        ").append(collectionField).append(".add(outputItem);\n")
                .append(indent).append("        ").append(counterVar != null ? counterVar.toLowerCase() : "counter").append("++;\n")
                .append(indent).append("    }\n")
                .append(indent).append("}\n");
        }

        if (nestingLevel == 0) {
            loop.append(indent).append("output.set").append(capitalize(collectionField)).append("(").append(collectionField).append(");");
        }

        logicBlocks.add(loop.toString());
    }

    private static void processWhileLoop(String condition, String body, String priorContent, List<String> logicBlocks,
            Map<String, ClassStructure> classes, Map<String, String> references, Map<String, String> variables) {
        if (body.contains("httpCode") || body.contains("httpMessage") || body.contains("moreInformation")) {
            return;
        }

        String resolvedCondition = condition.trim();
        String loopVar = "i";
        String maxIterations = "10"; // Default fallback

        if (resolvedCondition.matches("(\\w+)\\s+<=\\s+(\\w+)")) {
            String[] parts = resolvedCondition.split("\\s+<=\\s+");
            loopVar = parts[0].toLowerCase();
            String limitVar = parts[1];
            String limitValue = variables.getOrDefault(limitVar, "Integer:10").split(":")[1];
            maxIterations = limitValue;

            // Find the input array size to set the loop boundary
            Matcher inputMatcher = INPUT_PATTERN.matcher(body);
            String inputArrayPath = null;
            while (inputMatcher.find()) {
                String path = inputMatcher.group(1);
                if (path.matches(".*\\[" + loopVar.toUpperCase() + "\\]")) {
                    inputArrayPath = path;
                    break;
                }
            }

            StringBuilder loop = new StringBuilder();
            if (inputArrayPath != null) {
                String[] pathParts = inputArrayPath.split("\\.");
                StringBuilder getter = new StringBuilder("input");
                for (int i = 1; i < pathParts.length; i++) {
                    String part = pathParts[i].replace("*:", "");
                    if (part.matches("\\w+\\[\\w+\\]")) {
                        String arrayName = part.substring(0, part.indexOf('['));
                        getter.append(".get").append(capitalize(toCamelCase(arrayName))).append("()");
                    } else {
                        getter.append(".get").append(capitalize(toCamelCase(part))).append("()");
                    }
                }
                maxIterations = getter + " != null ? " + getter + ".size() : 0";
            }

            loop.append("int ").append(loopVar).append(" = ").append(variables.getOrDefault(loopVar, "Integer:1").split(":")[1]).append(";\n")
                .append("int max").append(capitalize(loopVar)).append(" = ").append(maxIterations).append(";\n")
                .append("while (").append(loopVar).append(" <= max").append(capitalize(loopVar)).append(") {\n")
                .append(convertLoopBodyWithCounter(body, null, "output", loopVar, references, variables, classes, 0))
                .append("    ").append(loopVar).append("++;\n")
                .append("}\n");

            logicBlocks.add(loop.toString());
        }
    }

    private static void processCreateLastChild(String parentPath, String domain, List<String> logicBlocks,
            Map<String, ClassStructure> classes, Map<String, String> references) {
        String resolvedPath = resolveReference(parentPath, references);
        ClassStructure targetClass = resolvedPath.startsWith("Environment") ? envClass : outputClass;

        String[] parts = resolvedPath.split("\\.");
        String fieldName = parts[parts.length - 1].toLowerCase();
        String className = capitalize(fieldName);
        ClassStructure nestedClass = classes.computeIfAbsent(className, ClassStructure::new);
        targetClass.addField(fieldName, className);

        StringBuilder create = new StringBuilder()
            .append("        ")
            .append(resolvedPath.startsWith("Environment") ? "environment" : "output")
            .append(".set").append(capitalize(fieldName)).append("(new ").append(className).append("());\n");

        logicBlocks.add(create.toString());
    }

    private static void processCreateField(String parentPath, String fieldName, String typeName, List<String> logicBlocks,
            Map<String, ClassStructure> classes, Map<String, String> references) {
        String resolvedPath = resolveReference(parentPath, references);
        ClassStructure targetClass;
        String root;

        if (resolvedPath.startsWith("Environment")) {
            targetClass = envClass;
            root = "environment";
        } else {
            targetClass = outputClass;
            root = "output";
        }

        String[] parts = resolvedPath.split("\\.");
        String className = parts.length > 2 ? capitalize(parts[2].replace("*:", "")) : targetClass.name;
        ClassStructure nestedClass = classes.computeIfAbsent(className, ClassStructure::new);
        String javaType = typeName != null ? TYPE_MAPPING.getOrDefault(typeName.toUpperCase(), "String") : "String";

        nestedClass.addField(fieldName.toLowerCase(), javaType);
        if (!className.equals(targetClass.name)) {
            targetClass.addField(parts[2].replace("*:", "").toLowerCase(), className);
        }

        String setter = "        " + root + ".get" + className + "().set" + capitalize(fieldName) + "(null);";
        logicBlocks.add(setter);
    }

    private static String generateSetter(String outputPath, String outputField, String value, Map<String, String> references,
            String castType, String coalesceValue, String defaultValue, Matcher headerMatcher, String iterator) {
        String root = outputPath.startsWith("Environment") ? "environment" : "output";
        String[] parts = outputPath.split("\\.");
        StringBuilder setterPath = new StringBuilder(root);

        // Determine the starting index based on the path
        int startIndex = 1; // Default for OutputRoot, Environment, or OutBodyRef
        if (outputPath.contains("XMLNSC")) {
            startIndex = 2; // Skip "OutputRoot.XMLNSC"
        } else if (outputPath.contains("JSON.Data")) {
            startIndex = 3; // Skip "OutputRoot.JSON.Data"
        } else if (outputPath.contains("MRM") || outputPath.contains("DFDL")) {
            startIndex = 2; // Skip "OutputRoot.MRM"
        } else if (outputPath.startsWith("OutBodyRef")) {
            startIndex = 1; // Skip "OutBodyRef"
        }

        // Build the path without redundant initialization checks
        for (int i = startIndex; i < parts.length - 1; i++) {
            String part = parts[i].replace("*:", "");
            if (part.matches("\\w+\\[\\d+\\]")) {
                String arrayName = part.substring(0, part.indexOf('['));
                int index = Integer.parseInt(part.substring(part.indexOf('[') + 1, part.indexOf(']'))) - 1; // Adjust for 0-based indexing
                setterPath.append(".get").append(capitalize(toCamelCase(arrayName))).append("().get(").append(index).append(")");
            } else {
                setterPath.append(".get").append(capitalize(toCamelCase(part))).append("()");
            }
        }

        // Convert outputField to camelCase, handling underscore-separated names
        String javaFieldName = toCamelCase(outputField);

        // Handle the value assignment
        String resolvedValue = resolveReference(value, references);
        Matcher inputMatcher = INPUT_PATTERN.matcher(resolvedValue);
        Matcher dateMatcher = DATE_PATTERN.matcher(resolvedValue);
        String setterLine;

        if (headerMatcher.find() && references.containsKey(headerMatcher.group(1))) {
            String headerKey = headerMatcher.group(2).toLowerCase();
            setterLine = setterPath + ".set" + capitalize(javaFieldName) + "(headers.get(\"" + headerKey + "\"));";
        } else if (dateMatcher.find()) {
            String dateExpr = dateMatcher.group(1);
            String format = dateMatcher.group(2);
            String javaFormat = convertDateFormat(format);
            String dateValue = dateExpr.equals("CURRENT_DATE") ? "LocalDateTime.now()" : convertValue(dateExpr);
            setterLine = setterPath + ".set" + capitalize(javaFieldName) + "(" + dateValue + ".format(DateTimeFormatter.ofPattern(\"" + javaFormat + "\")));";
        } else if (inputMatcher.find()) {
            String inputGetter = buildInputGetter(resolvedValue, iterator);
            if (coalesceValue != null) {
                String coalesceExpression = "Optional.ofNullable(" + inputGetter + ").orElse(" + defaultValue + ")";
                if (castType != null) {
                    coalesceExpression = applyCasting(coalesceExpression, castType);
                }
                setterLine = setterPath + ".set" + capitalize(javaFieldName) + "(" + coalesceExpression + ");";
            } else if (castType != null) {
                String castExpression = applyCasting(inputGetter, castType);
                setterLine = setterPath + ".set" + capitalize(javaFieldName) + "(" + castExpression + ");";
            } else {
                setterLine = setterPath + ".set" + capitalize(javaFieldName) + "(" + inputGetter + ");";
            }
        } else {
            String convertedValue = convertValue(resolvedValue);
            if (castType != null) {
                convertedValue = applyCasting(convertedValue, castType);
            }
            setterLine = setterPath + ".set" + capitalize(javaFieldName) + "(" + convertedValue + ");";
        }

        return "        " + setterLine;
    }

    private static String buildInputGetter(String resolvedValue, String iterator) {
        String[] inputParts = resolvedValue.split("\\.");
        StringBuilder inputGetter = new StringBuilder();
        int startIndex = resolvedValue.contains("MRM") || resolvedValue.contains("DFDL") ? 2 : resolvedValue.contains("JSON.Data") ? 3 : resolvedValue.contains("XMLNSC") ? 2 : 1;

        // Build the getter with null and bounds checking
        inputGetter.append("((");
        StringBuilder currentPath = new StringBuilder(iterator != null ? iterator : "input");
        for (int i = startIndex; i < inputParts.length; i++) {
            String part = inputParts[i].replace("*:", "");
            currentPath.append(".get").append(capitalize(toCamelCase(part))).append("()");
            if (i < inputParts.length - 1) {
                inputGetter.append(currentPath).append(" != null && ");
            }
        }

        if (inputParts[inputParts.length - 1].matches("\\w+\\[\\d+\\]")) {
            String arrayName = inputParts[inputParts.length - 1].substring(0, inputParts[inputParts.length - 1].indexOf('['));
            int index = Integer.parseInt(inputParts[inputParts.length - 1].substring(inputParts[inputParts.length - 1].indexOf('[') + 1, inputParts[inputParts.length - 1].indexOf(']'))) - 1;
            inputGetter.append(currentPath).append(" != null && ")
                       .append(currentPath).append(".size() > ").append(index).append(") ? ")
                       .append(currentPath).append(".get(").append(index).append(") : null)");
        } else {
            inputGetter.append(currentPath).append(" != null) ? ")
                       .append(currentPath).append(" : null)");
        }

        return inputGetter.toString();
    }

    private static String resolveReference(String path, Map<String, String> references) {
        if (references.containsKey(path)) {
            return references.get(path);
        }
        for (Map.Entry<String, String> entry : references.entrySet()) {
            if (path.startsWith(entry.getKey() + ".")) {
                return entry.getValue() + path.substring(entry.getKey().length());
            }
        }
        return path;
    }

    private static String extractCollectionName(String path, boolean isForLoop) {
        String[] parts = path.split("\\.");
        if (isForLoop) {
            for (int i = parts.length - 1; i >= 0; i--) {
                if (parts[i].startsWith("*:") && !parts[i].equals("*:item")) {
                    return parts[i].replace("*:", "").toLowerCase();
                }
            }
        } else {
            for (int i = parts.length - 1; i >= 0; i--) {
                if (parts[i].startsWith("*:") && !parts[i].matches("Item\\[.*?\\]")) {
                    return parts[i].replace("*:", "").toLowerCase();
                }
            }
        }
        return parts[parts.length - 1].replace("*:", "").toLowerCase();
    }

    private static void processPath(String fullPath, Map<String, ClassStructure> classes, ClassStructure rootClass,
            boolean isOutput, String value) {
        String[] parts = fullPath.split("\\.");
        if (parts.length < 2) {
            return;
        }

        if (fullPath.startsWith("Environment")) {
            processEnvironmentPath(fullPath, classes, rootClass, value);
        } else if (fullPath.contains("MRM") || fullPath.contains("DFDL")) {
            processDomainPath(fullPath, classes, rootClass, isOutput, value);
        } else if (fullPath.contains("JSON.Data")) {
            processJsonPath(fullPath, classes, rootClass, isOutput, value);
        } else if (fullPath.contains("XMLNSC")) {
            processXmlPath(fullPath, classes, rootClass, isOutput, value);
        } else if (fullPath.startsWith("OutBodyRef")) {
            processOutBodyRefPath(fullPath, classes, rootClass, isOutput, value);
        }
    }

    private static void processEnvironmentPath(String fullPath, Map<String, ClassStructure> classes, ClassStructure rootClass, String value) {
        String[] parts = fullPath.split("\\.");
        ClassStructure currentClass = rootClass;
        int startIndex = 1; // Start after "Environment"

        for (int i = startIndex; i < parts.length - 1; i++) {
            String fieldName = parts[i].replace("*:", "").toLowerCase();
            String nextClassName = capitalize(fieldName.replaceAll("s$", ""));
            if (i == parts.length - 2 && !parts[i + 1].matches("\\w+\\[\\d+\\]")) {
                String type = value instanceof String && TYPE_MAPPING.containsValue(value) ? value : determineFieldType(fieldName, fullPath, value);
                currentClass.addField(fieldName, type);
            } else {
                ClassStructure nestedClass = classes.computeIfAbsent(nextClassName, ClassStructure::new);
                currentClass.addField(fieldName, nextClassName);
                currentClass = nestedClass;
            }
        }
        if (!parts[parts.length - 1].matches("\\w+\\[\\d+\\]")) {
            String fieldName = parts[parts.length - 1].replace("*:", "").toLowerCase();
            String type = value instanceof String && TYPE_MAPPING.containsValue(value) ? value : determineFieldType(fieldName, fullPath, value);
            currentClass.addField(fieldName, type);
        } else {
            String arrayPart = parts[parts.length - 1];
            String arrayName = arrayPart.substring(0, arrayPart.indexOf('[')).toLowerCase();
            String arrayClassName = capitalize(arrayName);
            currentClass.addField(arrayName, isJsonStream ? "Stream<" + arrayClassName + ">" : "List<" + arrayClassName + ">");
            ClassStructure arrayClass = classes.computeIfAbsent(arrayClassName, ClassStructure::new);
            arrayClass.addField(parts[parts.length - 1].replace("*:", "").toLowerCase(), "String");
        }
    }

    private static void processDomainPath(String fullPath, Map<String, ClassStructure> classes, ClassStructure rootClass,
            boolean isOutput, String value) {
        String[] parts = fullPath.split("\\.");
        ClassStructure currentClass = rootClass;
        int startIndex = fullPath.contains("JSON.Data") ? 3 : 2;

        for (int i = startIndex; i < parts.length - 1; i++) {
            if (!parts[i].equals("MRM") && !parts[i].equals("DFDL") && !parts[i].equals("JSON") && !parts[i].equals("Data")) {
                String fieldName = parts[i].replace("*:", "").toLowerCase();
                String nextClassName = capitalize(fieldName);
                if (i == parts.length - 2 && !parts[i + 1].matches("\\w+\\[\\d+\\]")) {
                    String type = value instanceof String && TYPE_MAPPING.containsValue(value) ? value : determineFieldType(fieldName, fullPath, value);
                    currentClass.addField(fieldName, type);
                } else if (parts[i + 1].matches("\\w+\\[\\d+\\]")) {
                    String arrayName = parts[i + 1].substring(0, parts[i + 1].indexOf('[')).toLowerCase();
                    String arrayClassName = capitalize(arrayName);
                    currentClass.addField(arrayName, isJsonStream ? "Stream<" + arrayClassName + ">" : "List<" + arrayClassName + ">");
                    ClassStructure arrayClass = classes.computeIfAbsent(arrayClassName, ClassStructure::new);
                    currentClass = arrayClass;
                    break;
                } else {
                    ClassStructure nestedClass = classes.computeIfAbsent(nextClassName, ClassStructure::new);
                    currentClass.addField(fieldName, nextClassName);
                    currentClass = nestedClass;
                }
            }
        }
        if (!parts[parts.length - 1].matches("\\w+\\[\\d+\\]")) {
            String fieldName = parts[parts.length - 1].replace("*:", "").toLowerCase();
            String type = value instanceof String && TYPE_MAPPING.containsValue(value) ? value : determineFieldType(fieldName, fullPath, value);
            currentClass.addField(fieldName, type);
        }
    }

    private static void processJsonPath(String fullPath, Map<String, ClassStructure> classes, ClassStructure rootClass,
            boolean isOutput, String value) {
        String[] parts = fullPath.split("\\.");
        ClassStructure currentClass = rootClass;
        int startIndex = 3; // Start after "InputRoot.JSON.Data" or "OutputRoot.JSON.Data"

        for (int i = startIndex; i < parts.length - 1; i++) {
            String fieldName = parts[i].replace("*:", "").toLowerCase();
            String nextClassName = capitalize(fieldName.replaceAll("s$", ""));
            if (parts[i].matches("\\w+\\[\\d+\\]")) {
                String arrayName = fieldName.substring(0, fieldName.indexOf('['));
                String arrayClassName = capitalize(arrayName);
                currentClass.addField(arrayName, isJsonStream ? "Stream<" + arrayClassName + ">" : "List<" + arrayClassName + ">");
                currentClass = classes.computeIfAbsent(arrayClassName, ClassStructure::new);
            } else {
                ClassStructure nestedClass = classes.computeIfAbsent(nextClassName, ClassStructure::new);
                currentClass.addField(fieldName, nextClassName);
                currentClass = nestedClass;
            }
        }

        String fieldName = parts[parts.length - 1].replace("*:", "").toLowerCase();
        String type;
        if (fieldName.matches("\\w+\\[\\d+\\]")) {
            String arrayName = fieldName.substring(0, fieldName.indexOf('[')).toLowerCase();
            String arrayClassName = capitalize(arrayName);
            type = isJsonStream ? "Stream<" + arrayClassName + ">" : "List<" + arrayClassName + ">";
            ClassStructure arrayClass = classes.computeIfAbsent(arrayClassName, ClassStructure::new);
            arrayClass.addField("value", "String");
        } else {
            type = value instanceof String && TYPE_MAPPING.containsValue(value) ? value : determineFieldType(fieldName, fullPath, value);
        }
        currentClass.addField(fieldName, type);
    }

    private static void processXmlPath(String fullPath, Map<String, ClassStructure> classes, ClassStructure rootClass,
            boolean isOutput, String value) {
        String[] parts = fullPath.split("\\.");
        ClassStructure currentClass = rootClass;
        int startIndex = 2; // Start after "InputRoot.XMLNSC" or "OutputRoot.XMLNSC"

        for (int i = startIndex; i < parts.length - 1; i++) {
            String fieldName = parts[i].replace("*:", "").toLowerCase();
            String nextClassName = capitalize(fieldName);
            ClassStructure nestedClass = classes.computeIfAbsent(nextClassName, ClassStructure::new);
            currentClass.addField(fieldName, nextClassName);
            currentClass = nestedClass;
        }

        String fieldName = parts[parts.length - 1].replace("*:", "").toLowerCase();
        String type;
        if (fieldName.matches("\\w+\\[\\d+\\]")) {
            String arrayName = fieldName.substring(0, fieldName.indexOf('[')).toLowerCase();
            String arrayClassName = capitalize(arrayName);
            type = "List<" + arrayClassName + ">";
            ClassStructure arrayClass = classes.computeIfAbsent(arrayClassName, ClassStructure::new);
            arrayClass.addField("value", "String");
        } else {
            type = value instanceof String && TYPE_MAPPING.containsValue(value) ? value : determineFieldType(fieldName, fullPath, value);
        }
        currentClass.addField(fieldName, type);
    }

    private static void processOutBodyRefPath(String fullPath, Map<String, ClassStructure> classes, ClassStructure rootClass,
            boolean isOutput, String value) {
        String[] parts = fullPath.split("\\.");
        ClassStructure currentClass = rootClass;
        int startIndex = 1; // Start after "OutBodyRef"

        for (int i = startIndex; i < parts.length - 1; i++) {
            String fieldName = parts[i].replace("*:", "").toLowerCase();
            String nextClassName = capitalize(fieldName);
            if (i == parts.length - 2 && !parts[i + 1].matches("\\w+\\[\\d+\\]")) {
                String type = value instanceof String && TYPE_MAPPING.containsValue(value) ? value : determineFieldType(fieldName, fullPath, value);
                currentClass.addField(fieldName, type);
            } else if (parts[i + 1].matches("\\w+\\[\\d+\\]")) {
                String arrayName = parts[i + 1].substring(0, parts[i + 1].indexOf('[')).toLowerCase();
                String arrayClassName = capitalize(arrayName);
                currentClass.addField(arrayName, isJsonStream ? "Stream<" + arrayClassName + ">" : "List<" + arrayClassName + ">");
                ClassStructure arrayClass = classes.computeIfAbsent(arrayClassName, ClassStructure::new);
                currentClass = arrayClass;
                break;
            } else {
                ClassStructure nestedClass = classes.computeIfAbsent(nextClassName, ClassStructure::new);
                currentClass.addField(fieldName, nextClassName);
                currentClass = nestedClass;
            }
        }

        if (!parts[parts.length - 1].matches("\\w+\\[\\d+\\]")) {
            String fieldName = parts[parts.length - 1].replace("*:", "").toLowerCase();
            String type = value instanceof String && TYPE_MAPPING.containsValue(value) ? value : determineFieldType(fieldName, fullPath, value);
            currentClass.addField(fieldName, type);
        }
    }

    private static void generateModelClasses(Map<String, Object> parseResult) throws IOException {
        Map<String, ClassStructure> classes = (Map<String, ClassStructure>) parseResult.get("classes");

        for (ClassStructure cls : classes.values()) {
            if (cls.name.isEmpty() || cls.fields.isEmpty()) continue;
            StringBuilder content = new StringBuilder()
                .append("package ").append(MODEL_PACKAGE).append(";\n\n")
                .append("import lombok.Data;\n")
                .append("import java.util.*;\n")
                .append("import java.time.LocalDateTime;\n")
                .append("import java.util.stream.Stream;\n\n")
                .append("@Data\n")
                .append("public class ").append(cls.name).append(" {\n");

            for (Map.Entry<String, String> field : cls.fields.entrySet()) {
                content.append("    private ").append(field.getValue()).append(" ").append(field.getKey()).append(";\n");
            }
            content.append("}\n");
            writeToFile(OUTPUT_DIR + cls.name + ".java", content.toString());
        }
    }

    private static void generateMapperClass(Map<String, Object> parseResult) throws IOException {
        List<String> logicBlocks = (List<String>) parseResult.get("logicBlocks");
        Map<String, List<String>> procedureBlocks = (Map<String, List<String>>) parseResult.get("procedureBlocks");
        Set<String> headerKeys = (Set<String>) parseResult.get("headerKeys");
        Set<String> arraysToInit = (Set<String>) parseResult.get("arraysToInitialize");

        StringBuilder mapper = new StringBuilder()
            .append("package ").append(MAPPER_PACKAGE).append(";\n\n")
            .append("import ").append(MODEL_PACKAGE).append(".*;\n")
            .append("import java.util.*;\n")
            .append("import java.util.stream.*;\n")
            .append("import java.time.LocalDateTime;\n")
            .append("import java.time.format.DateTimeFormatter;\n")
            .append("import com.fasterxml.jackson.databind.JsonNode;\n")
            .append("import com.fasterxml.jackson.databind.ObjectMapper;\n\n")
            .append("public class DataMapper {\n");

        mapper.append("    private final ObjectMapper objectMapper = new ObjectMapper();\n\n");

        for (Map.Entry<String, List<String>> entry : procedureBlocks.entrySet()) {
            String methodName = entry.getKey().substring(0, 1).toLowerCase() + entry.getKey().substring(1);
            mapper.append("    private void ").append(methodName).append("(Input input, Output output, Environment environment, Map<String, String> headersMap) {\n");
            for (String block : entry.getValue()) {
                mapper.append("        ").append(block).append("\n");
            }
            mapper.append("    }\n\n");
        }

        mapper.append("    public Output map(Input input, Map<String, String> headers, String requestIdentifier) {\n")
              .append("        Map<String, String> headersMap = new HashMap<>();\n");

        for (String key : headerKeys) {
            mapper.append("        headersMap.put(\"").append(key).append("\", headers.get(\"").append(key).append("\"));\n");
        }

        mapper.append("        Output output = new Output();\n")
              .append("        Environment environment = new Environment();\n");

        // Initialize all necessary objects and arrays at the start
        mapper.append("        // Initialize nested objects and arrays\n");
        if (outputClass.fields.containsKey("reqdatrxhbuftbl")) {
            mapper.append("        output.setReqdatrxhbuftbl(new Reqdatrxhbuftbl());\n");
        }
        if (envClass.fields.containsKey("variables")) {
            mapper.append("        environment.setVariables(new Variables());\n");
        }

        // Initialize arrays with sufficient size
        for (String arrayPath : arraysToInit) {
            String[] parts = arrayPath.split("\\.");
            StringBuilder path = new StringBuilder();
            String root = arrayPath.startsWith("Environment") ? "environment" : "output";
            int startIndex = arrayPath.startsWith("Environment") || arrayPath.startsWith("OutBodyRef") ? 1 : 3;
            path.append(root);

            for (int i = startIndex; i < parts.length; i++) {
                String part = parts[i].replace("*:", "");
                path.append(".get").append(capitalize(toCamelCase(part))).append("()");
            }

            // Determine the maximum index needed for this array
            int maxIndex = 0;
            Matcher indexMatcher = Pattern.compile(arrayPath + "\\[(\\d+)\\]").matcher(String.join("\n", logicBlocks));
            while (indexMatcher.find()) {
                int index = Integer.parseInt(indexMatcher.group(1)) - 1; // Adjust for 0-based indexing
                maxIndex = Math.max(maxIndex, index);
            }

            String arrayClassName = capitalize(toCamelCase(parts[parts.length - 1]));
            mapper.append("        ").append(path).append(" = new ArrayList<>();\n");
            mapper.append("        for (int i = 0; i <= ").append(maxIndex).append("; i++) {\n");
            mapper.append("            ").append(path).append(".add(new ").append(arrayClassName).append("());\n");
            mapper.append("        }\n");
        }

        // Add logic blocks
        for (String block : logicBlocks) {
            mapper.append(block).append("\n");
        }

        for (String procName : procedureBlocks.keySet()) {
            String methodName = procName.substring(0, 1).toLowerCase() + procName.substring(1);
            mapper.append("        ").append(methodName).append("(input, output, environment, headersMap);\n");
        }

        mapper.append("        return output;\n")
              .append("    }\n")
              .append("}\n");

        writeToFile(OUTPUT_DIR + "DataMapper.java", mapper.toString());
    }

    static class ClassStructure {
        String name;
        Map<String, String> fields = new LinkedHashMap<>();

        ClassStructure(String name) {
            this.name = name;
        }

        void addField(String name, String type) {
            fields.putIfAbsent(name, type);
        }
    }

    private static String determineFieldType(String fieldName, String fullPath, String value) {
        if (value != null) {
            if (fieldName.toLowerCase().contains("date") || fieldName.toLowerCase().contains("time")) {
                return "LocalDateTime";
            }
            if (value.matches("'true'|'false'|TRUE|FALSE")) return "String";
            if (value.matches("\\d+")) return "Integer";
            if (value.startsWith("'") && value.endsWith("'")) return "String";
            if (!value.contains("InputRoot")) return "String";
        }
        return "String";
    }

    private static String capitalize(String str) {
        if (str == null || str.isEmpty()) return str;
        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();
    }

    private static String toCamelCase(String esqlFieldName) {
        String[] parts = esqlFieldName.toLowerCase().split("_");
        StringBuilder camelCase = new StringBuilder(parts[0]);
        for (int i = 1; i < parts.length; i++) {
            camelCase.append(capitalize(parts[i]));
        }
        return camelCase.toString();
    }

    private static String convertValue(String value) {
        if (value.startsWith("'") && value.endsWith("'")) {
            String val = value.substring(1, value.length - 1);
            if ("true".equalsIgnoreCase(val) || "false".equalsIgnoreCase(val)) return "\"" + val.toUpperCase() + "\"";
            return "\"" + val + "\"";
        }
        if ("TRUE".equalsIgnoreCase(value)) return "\"TRUE\"";
        if ("FALSE".equalsIgnoreCase(value)) return "\"FALSE\"";
        if ("CURRENT_DATE".equalsIgnoreCase(value)) return "LocalDateTime.now()";
        if (value.matches("\\d+")) return value;
        return value;
    }

    private static String applyCasting(String expression, String javaType) {
        switch (javaType) {
            case "Integer": return "Integer.parseInt(" + expression + ")";
            case "Float": return "Float.parseFloat(" + expression + ")";
            case "Double": return "Double.parseDouble(" + expression + ")";
            case "Boolean": return "Boolean.parseBoolean(" + expression + ")";
            case "String": return "String.valueOf(" + expression + ")";
            default: return expression;
        }
    }

    private static String convertLoopBodyWithCounter(String body, String iterator, String itemVar, String counterVar,
            Map<String, String> references, Map<String, String> variables, Map<String, ClassStructure> classes, int nestingLevel) {
        StringBuilder result = new StringBuilder();
        int lastPos = 0;

        Matcher setMatcher = LOOP_INDEX_PATTERN.matcher(body);
        Matcher ifMatcher = IF_PATTERN.matcher(body);
        Matcher forMatcher = FOR_PATTERN.matcher(body);
        Matcher incompleteSetMatcher = INCOMPLETE_SET_PATTERN.matcher(body);

        while (lastPos < body.length()) {
            int nextSetPos = setMatcher.find(lastPos) ? setMatcher.start() : Integer.MAX_VALUE;
            int nextIfPos = ifMatcher.find(lastPos) ? ifMatcher.start() : Integer.MAX_VALUE;
            int nextForPos = forMatcher.find(lastPos) ? forMatcher.start() : Integer.MAX_VALUE;
            int nextIncompleteSetPos = incompleteSetMatcher.find(lastPos) ? incompleteSetMatcher.start() : Integer.MAX_VALUE;

            if (nextSetPos == Integer.MAX_VALUE && nextIfPos == Integer.MAX_VALUE && nextForPos == Integer.MAX_VALUE && nextIncompleteSetPos == Integer.MAX_VALUE) {
                break;
            }

            int nextPos = Math.min(Math.min(nextSetPos, nextIfPos), Math.min(nextForPos, nextIncompleteSetPos));

            if (nextPos == nextSetPos) {
                String field = setMatcher.group(3).toLowerCase();
                String value = setMatcher.group(4).trim();
                String resolvedValue = resolveReference(value, references);

                if (field.equals("httpcode") || field.equals("httpmessage") || field.equals("moreinformation")
                        || resolvedValue.contains("httpCode") || resolvedValue.contains("httpMessage")
                        || resolvedValue.contains("moreInformation")) {
                    lastPos = setMatcher.end();
                    continue;
                }

                String setter;
                Matcher castMatcher = CAST_PATTERN.matcher(value);
                Matcher coalesceMatcher = COALESCE_PATTERN.matcher(value);
                Matcher dateMatcher = DATE_PATTERN.matcher(value);
                if (coalesceMatcher.find()) {
                    String[] args = coalesceMatcher.group(1).split(",");
                    String coalesceValue = args[0].trim();
                    String defaultValue = args.length > 1 ? args[1].trim().replaceAll("'", "\"") : "\"\"";
                    String inputGetter = buildInputGetter(resolveReference(coalesceValue, references), iterator);
                    setter = itemVar + ".set" + capitalize(field) + "(Optional.ofNullable(" + inputGetter + ").orElse(" + defaultValue + "));";
                } else if (castMatcher.find()) {
                    String castExpr = castMatcher.group(1).trim();
                    String castType = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
                    String inputGetter = buildInputGetter(resolveReference(castExpr, references), iterator);
                    setter = itemVar + ".set" + capitalize(field) + "(" + applyCasting(inputGetter, castType) + ");";
                } else if (dateMatcher.find()) {
                    String dateExpr = dateMatcher.group(1);
                    String format = dateMatcher.group(2);
                    String javaFormat = convertDateFormat(format);
                    String resolvedDateExpr = resolveReference(dateExpr, references);
                    String dateValue = resolvedDateExpr.contains("InputRoot") ? buildInputGetter(resolvedDateExpr, iterator) : convertValue(resolvedDateExpr);
                    setter = itemVar + ".set" + capitalize(field) + "(LocalDateTime.parse(" + dateValue + ", DateTimeFormatter.ofPattern(\"" + javaFormat + "\")));";
                } else {
                    String inputGetter = buildInputGetter(resolvedValue, iterator);
                    setter = itemVar + ".set" + capitalize(field) + "(" + inputGetter + ");";
                }
                result.append("        ").append(setter).append("\n");
                lastPos = setMatcher.end();
            } else if (nextPos == nextIncompleteSetPos) {
                String outputPath = incompleteSetMatcher.group(1).trim();
                String value = incompleteSetMatcher.group(2).trim();
                if (!value.isEmpty()) {
                    String[] outputParts = outputPath.split("\\.");
                    String field = outputParts[outputParts.length - 1].toLowerCase();
                    String resolvedValue = resolveReference(value, references);

                    if (field.equals("httpcode") || field.equals("httpmessage") || field.equals("moreinformation")
                            || resolvedValue.contains("httpCode") || resolvedValue.contains("httpMessage")
                            || resolvedValue.contains("moreInformation")) {
                        lastPos = incompleteSetMatcher.end();
                        continue;
                    }

                    String setter;
                    Matcher castMatcher = CAST_PATTERN.matcher(value);
                    Matcher coalesceMatcher = COALESCE_PATTERN.matcher(value);
                    Matcher dateMatcher = DATE_PATTERN.matcher(value);
                    if (coalesceMatcher.find()) {
                        String[] args = coalesceMatcher.group(1).split(",");
                        String coalesceValue = args[0].trim();
                        String defaultValue = args.length > 1 ? args[1].trim().replaceAll("'", "\"") : "\"\"";
                        String inputGetter = buildInputGetter(resolveReference(coalesceValue, references), iterator);
                        setter = itemVar + ".set" + capitalize(field) + "(Optional.ofNullable(" + inputGetter + ").orElse(" + defaultValue + "));";
                    } else if (castMatcher.find()) {
                        String castExpr = castMatcher.group(1).trim();
                        String castType = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
                        String inputGetter = buildInputGetter(resolveReference(castExpr, references), iterator);
                        setter = itemVar + ".set" + capitalize(field) + "(" + applyCasting(inputGetter, castType) + ");";
                    } else if (dateMatcher.find()) {
                        String dateExpr = dateMatcher.group(1);
                        String format = dateMatcher.group(2);
                        String javaFormat = convertDateFormat(format);
                        String resolvedDateExpr = resolveReference(dateExpr, references);
                        String dateValue = resolvedDateExpr.contains("InputRoot") ? buildInputGetter(resolvedDateExpr, iterator) : convertValue(resolvedDateExpr);
                        setter = itemVar + ".set" + capitalize(field) + "(LocalDateTime.parse(" + dateValue + ", DateTimeFormatter.ofPattern(\"" + javaFormat + "\")));";
                    } else {
                        String inputGetter = buildInputGetter(resolvedValue, iterator);
                        setter = itemVar + ".set" + capitalize(field) + "(" + inputGetter + ");";
                    }
                    result.append("        ").append(setter).append("\n");
                }
                lastPos = incompleteSetMatcher.end();
            } else if (nextPos == nextIfPos) {
                String condition = ifMatcher.group(1).trim();
                String thenBlock = ifMatcher.group(2).trim();
                String elseBlock = ifMatcher.group(3) != null ? ifMatcher.group(3).trim() : null;

                String resolvedCondition = resolveReference(condition, references);
                String conditionExpr = convertCondition(resolvedCondition, iterator, references);

                StringBuilder ifBlock = new StringBuilder();
                ifBlock.append("        if (").append(conditionExpr).append(") {\n");

                Matcher thenSetter = LOOP_INDEX_PATTERN.matcher(thenBlock);
                while (thenSetter.find()) {
                    String field = thenSetter.group(3).toLowerCase();
                    String value = thenSetter.group(4).trim();
                    String resolvedValue = resolveReference(value, references);

                    if (field.equals("httpcode") || field.equals("httpmessage") || field.equals("moreinformation")
                            || resolvedValue.contains("httpCode") || resolvedValue.contains("httpMessage")
                            || resolvedValue.contains("moreInformation")) {
                        continue;
                    }

                    String setter;
                    Matcher castMatcher = CAST_PATTERN.matcher(value);
                    Matcher coalesceMatcher = COALESCE_PATTERN.matcher(value);
                    if (coalesceMatcher.find()) {
                        String[] args = coalesceMatcher.group(1).split(",");
                        String coalesceValue = args[0].trim();
                        String defaultValue = args.length > 1 ? args[1].trim().replaceAll("'", "\"") : "\"\"";
                        String inputGetter = buildInputGetter(resolveReference(coalesceValue, references), iterator);
                        setter = itemVar + ".set" + capitalize(field) + "(Optional.ofNullable(" + inputGetter + ").orElse(" + defaultValue + "));";
                    } else if (castMatcher.find()) {
                        String castExpr = castMatcher.group(1).trim();
                        String castType = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
                        String inputGetter = buildInputGetter(resolveReference(castExpr, references), iterator);
                        setter = itemVar + ".set" + capitalize(field) + "(" + applyCasting(inputGetter, castType) + ");";
                    } else {
                        String inputGetter = buildInputGetter(resolvedValue, iterator);
                        setter = itemVar + ".set" + capitalize(field) + "(" + convertValue(resolvedValue) + ");";
                    }
                    ifBlock.append("            ").append(setter).append("\n");
                }

                if (elseBlock != null) {
                    ifBlock.append("        } else {\n");
                    Matcher elseSetter = LOOP_INDEX_PATTERN.matcher(elseBlock);
                    while (elseSetter.find()) {
                        String field = elseSetter.group(3).toLowerCase();
                        String value = elseSetter.group(4).trim();
                        String resolvedValue = resolveReference(value, references);

                        if (field.equals("httpcode") || field.equals("httpmessage") || field.equals("moreinformation")
                                || resolvedValue.contains("httpCode") || resolvedValue.contains("httpMessage")
                                || resolvedValue.contains("moreInformation")) {
                            continue;
                        }

                        String setter;
                        Matcher castMatcher = CAST_PATTERN.matcher(value);
                        Matcher coalesceMatcher = COALESCE_PATTERN.matcher(value);
                        if (coalesceMatcher.find()) {
                            String[] args = coalesceMatcher.group(1).split(",");
                            String coalesceValue = args[0].trim();
                            String defaultValue = args.length > 1 ? args[1].trim().replaceAll("'", "\"") : "\"\"";
                            String inputGetter = buildInputGetter(resolveReference(coalesceValue, references), iterator);
                            setter = itemVar + ".set" + capitalize(field) + "(Optional.ofNullable(" + inputGetter + ").orElse(" + defaultValue + "));";
                        } else if (castMatcher.find()) {
                            String castExpr = castMatcher.group(1).trim();
                            String castType = TYPE_MAPPING.getOrDefault(castMatcher.group(2).toUpperCase(), "String");
                            String inputGetter = buildInputGetter(resolveReference(castExpr, references), iterator);
                            setter = itemVar + ".set" + capitalize(field) + "(" + applyCasting(inputGetter, castType) + ");";
                        } else {
                            String inputGetter = buildInputGetter(resolvedValue, iterator);
                            setter = itemVar + ".set" + capitalize(field) + "(" + convertValue(resolvedValue) + ");";
                        }
                        ifBlock.append("            ").append(setter).append("\n");
                    }
                }
                ifBlock.append("        }\n");

                result.append(ifBlock);
                lastPos = ifMatcher.end();
            } else if (nextPos == nextForPos) {
                List<String> nestedLoopBlocks = new ArrayList<>();
                processForLoop(forMatcher.group(1), forMatcher.group(2), forMatcher.group(3), nestedLoopBlocks, classes,
                        references, variables, nestingLevel + 1);
                for (String block : nestedLoopBlocks) {
                    result.append("        ").append(block.replace("\n", "\n        ")).append("\n");
                }
                lastPos = forMatcher.end();
            }
        }

        return result.toString();
    }

    private static String convertCondition(String condition, String iterator, Map<String, String> references) {
        String resolvedCondition = resolveReference(condition, references);
        Matcher inputMatcher = INPUT_PATTERN.matcher(resolvedCondition);
        if (inputMatcher.find()) {
            String inputGetter = buildInputGetter(resolvedCondition, iterator);
            if (condition.contains("=")) {
                String[] parts = condition.split("=");
                String value = parts[1].trim();
                return inputGetter + ".equals(" + convertValue(value) + ")";
            }
            return inputGetter;
        }
        return convertValue(condition);
    }

    private static String detectCounterVariable(String body, Map<String, String> variables) {
        Matcher matcher = LOOP_INDEX_PATTERN.matcher(body);
        while (matcher.find()) {
            String indexVar = matcher.group(2);
            if (variables.containsKey(indexVar)) {
                return indexVar;
            }
        }
        return null;
    }

    private static String extractOutputCollection(String body, Map<String, String> references, String inputCollectionName) {
        Matcher matcher = LOOP_INDEX_PATTERN.matcher(body);
        if (matcher.find()) {
            String rawPath = matcher.group(1).trim();
            String resolvedPath = resolveReference(rawPath, references);
            if (!resolvedPath.matches("(OutputRoot\\.(JSON\\.Data|XMLNSC|MRM|DFDL)|Environment|OutBodyRef).*")) {
                resolvedPath = "OutputRoot.JSON.Data." + resolvedPath;
            }
            return resolvedPath;
        }
        return "OutputRoot.JSON.Data." + inputCollectionName;
    }

    private static boolean isWithinProcedure(int position, Matcher procedureMatcher) {
        procedureMatcher.reset();
        while (procedureMatcher.find()) {
            if (position >= procedureMatcher.start() && position <= procedureMatcher.end()) {
                return true;
            }
        }
        return false;
    }

    private static void writeToFile(String filePath, String content) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath, StandardCharsets.UTF_8))) {
            writer.write(content);
        }
    }

    private static String convertDateFormat(String esqlFormat) {
        return esqlFormat.replace("%Y", "yyyy").replace("%y", "yy").replace("%m", "MM").replace("%d", "dd")
                .replace("%H", "HH").replace("%h", "hh").replace("%M", "mm").replace("%S", "ss")
                .replace("%f", "SSS").replace("%a", "EEE").replace("%A", "EEEE").replace("%b", "MMM")
                .replace("%B", "MMMM").replace("%p", "a").replace("%z", "Z").replace("%Z", "z");
    }
}
