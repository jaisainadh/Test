import java.util.*;

public class GenericEsqlToJavaConverter {

    // Step 1: Parse ESQL code and extract constructs
    public static Map<String, List<String>> parseEsql(String esqlCode) {
        Map<String, List<String>> constructs = new HashMap<>();
        constructs.put("SET", new ArrayList<>());
        constructs.put("FOR", new ArrayList<>());
        constructs.put("IF", new ArrayList<>());
        constructs.put("WHILE", new ArrayList<>());

        String[] lines = esqlCode.split("\n");
        for (String line : lines) {
            line = line.trim();
            if (line.startsWith("SET")) {
                constructs.get("SET").add(line);
            } else if (line.startsWith("FOR")) {
                constructs.get("FOR").add(line);
            } else if (line.startsWith("IF")) {
                constructs.get("IF").add(line);
            } else if (line.startsWith("WHILE")) {
                constructs.get("WHILE").add(line);
            }
        }
        return constructs;
    }

    // Step 2: Extract input and output fields from SET statements
    public static Set<String> extractFields(List<String> setStatements, String prefix) {
        Set<String> fields = new HashSet<>();
        for (String statement : setStatements) {
            try {
                String[] parts = statement.split("=");
                if (parts.length < 2) {
                    System.err.println("Invalid SET statement: " + statement);
                    continue;
                }
                String left = parts[0].trim(); // e.g., output.fieldName
                String[] leftParts = left.split("\\.");
                if (leftParts.length < 3) {
                    System.err.println("Invalid field reference: " + left);
                    continue;
                }
                String field = leftParts[2]; // e.g., output.fieldName -> fieldName
                if (left.startsWith(prefix)) {
                    fields.add(field);
                }
            } catch (Exception e) {
                System.err.println("Error parsing SET statement: " + statement);
                e.printStackTrace();
            }
        }
        return fields;
    }

    // Step 3: Generate Java model classes with Lombok @Data
    public static String generateModelClasses(Set<String> inputFields, Set<String> outputFields) {
        StringBuilder code = new StringBuilder();

        // Add Lombok import
        code.append("import lombok.Data;\n\n");

        // Input model class
        code.append("@Data\n");
        code.append("public class InputData {\n");
        for (String field : inputFields) {
            code.append("    private String ").append(field).append(";\n");
        }
        code.append("}\n\n");

        // Output model class
        code.append("@Data\n");
        code.append("public class OutputData {\n");
        for (String field : outputFields) {
            code.append("    private String ").append(field).append(";\n");
        }
        code.append("}\n\n");

        return code.toString();
    }

    // Step 4: Generate Java transformation logic
    public static String generateTransformationLogic(Map<String, List<String>> constructs) {
        StringBuilder code = new StringBuilder();

        code.append("public class EsqlToJavaTransformer {\n\n");
        code.append("    public OutputData transform(InputData input) {\n");
        code.append("        OutputData output = new OutputData();\n\n");

        // Process SET statements
        for (String statement : constructs.get("SET")) {
            try {
                String[] parts = statement.split("=");
                if (parts.length < 2) {
                    System.err.println("Invalid SET statement: " + statement);
                    continue;
                }
                String left = parts[0].trim(); // e.g., output.fieldName
                String right = parts[1].trim(); // e.g., input.fieldName
                String[] leftParts = left.split("\\.");
                if (leftParts.length < 3) {
                    System.err.println("Invalid field reference: " + left);
                    continue;
                }
                String field = leftParts[2]; // e.g., output.fieldName -> fieldName
                code.append("        output.set").append(capitalize(field)).append("(").append(right).append(");\n");
            } catch (Exception e) {
                System.err.println("Error processing SET statement: " + statement);
                e.printStackTrace();
            }
        }

        // Process FOR loops
        for (String loop : constructs.get("FOR")) {
            code.append("        // FOR loop equivalent\n");
            code.append("        for (int i = 0; i < input.getArrayLength(); i++) {\n");
            code.append("            // Add loop logic here\n");
            code.append("        }\n\n");
        }

        // Process IF conditions
        for (String condition : constructs.get("IF")) {
            code.append("        // IF condition equivalent\n");
            code.append("        if (").append(condition.replace("IF", "").replace("THEN", "").trim()).append(") {\n");
            code.append("            // Add IF logic here\n");
            code.append("        } else {\n");
            code.append("            // Add ELSE logic here\n");
            code.append("        }\n\n");
        }

        // Process WHILE loops
        for (String loop : constructs.get("WHILE")) {
            code.append("        // WHILE loop equivalent\n");
            code.append("        while (").append(loop.replace("WHILE", "").replace("DO", "").trim()).append(") {\n");
            code.append("            // Add loop logic here\n");
            code.append("        }\n\n");
        }

        code.append("        return output;\n");
        code.append("    }\n\n");

        // Main method for testing
        code.append("    public static void main(String[] args) {\n");
        code.append("        // Example usage\n");
        code.append("        InputData input = new InputData();\n");
        code.append("        EsqlToJavaTransformer transformer = new EsqlToJavaTransformer();\n");
        code.append("        OutputData output = transformer.transform(input);\n\n");
        code.append("        // Print output\n");
        code.append("        System.out.println(\"Output: \" + output);\n");
        code.append("    }\n");
        code.append("}\n");

        return code.toString();
    }

    // Helper method to capitalize the first letter of a string
    private static String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }

    // Main method to run the converter
    public static void main(String[] args) {
        // Example ESQL code
        String esqlCode = "SET output.firstName = input.firstName;\n" +
                          "SET output.lastName = input.lastName;\n" +
                          "SET output.fullName = input.firstName || ' ' || input.lastName;\n" +
                          "FOR i AS 1 TO input.arrayLength DO\n" +
                          "    SET total = total + input.array[i];\n" +
                          "END FOR;\n" +
                          "IF total > 100 THEN\n" +
                          "    SET output.status = 'High';\n" +
                          "ELSE\n" +
                          "    SET output.status = 'Low';\n" +
                          "END IF;\n" +
                          "WHILE i < input.arrayLength DO\n" +
                          "    SET output.array[i] = input.array[i] * 2;\n" +
                          "    SET i = i + 1;\n" +
                          "END WHILE;";

        // Step 1: Parse ESQL
        Map<String, List<String>> constructs = parseEsql(esqlCode);

        // Step 2: Extract input and output fields
        Set<String> inputFields = extractFields(constructs.get("SET"), "input");
        Set<String> outputFields = extractFields(constructs.get("SET"), "output");

        // Step 3: Generate model classes with Lombok
        String modelClasses = generateModelClasses(inputFields, outputFields);

        // Step 4: Generate transformation logic
        String transformationLogic = generateTransformationLogic(constructs);

        // Output the generated Java code
        System.out.println("// Generated Model Classes\n");
        System.out.println(modelClasses);

        System.out.println("// Generated Transformation Logic\n");
        System.out.println(transformationLogic);
    }
}
